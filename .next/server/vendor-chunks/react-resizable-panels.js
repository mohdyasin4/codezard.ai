"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/react-resizable-panels";
exports.ids = ["vendor-chunks/react-resizable-panels"];
exports.modules = {

/***/ "(ssr)/./node_modules/react-resizable-panels/dist/react-resizable-panels.development.node.esm.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/react-resizable-panels/dist/react-resizable-panels.development.node.esm.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Panel: () => (/* binding */ Panel),\n/* harmony export */   PanelGroup: () => (/* binding */ PanelGroup),\n/* harmony export */   PanelResizeHandle: () => (/* binding */ PanelResizeHandle),\n/* harmony export */   assert: () => (/* binding */ assert),\n/* harmony export */   getIntersectingRectangle: () => (/* binding */ getIntersectingRectangle),\n/* harmony export */   getPanelElement: () => (/* binding */ getPanelElement),\n/* harmony export */   getPanelElementsForGroup: () => (/* binding */ getPanelElementsForGroup),\n/* harmony export */   getPanelGroupElement: () => (/* binding */ getPanelGroupElement),\n/* harmony export */   getResizeHandleElement: () => (/* binding */ getResizeHandleElement),\n/* harmony export */   getResizeHandleElementIndex: () => (/* binding */ getResizeHandleElementIndex),\n/* harmony export */   getResizeHandleElementsForGroup: () => (/* binding */ getResizeHandleElementsForGroup),\n/* harmony export */   getResizeHandlePanelIds: () => (/* binding */ getResizeHandlePanelIds),\n/* harmony export */   intersects: () => (/* binding */ intersects)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n\n\n// This module exists to work around Webpack issue https://github.com/webpack/webpack/issues/14814\n\n// eslint-disable-next-line no-restricted-imports\n\nconst {\n  createElement,\n  createContext,\n  createRef,\n  forwardRef,\n  useCallback,\n  useContext,\n  useEffect,\n  useImperativeHandle,\n  useLayoutEffect,\n  useMemo,\n  useRef,\n  useState\n} = react__WEBPACK_IMPORTED_MODULE_0__;\n\n// `toString()` prevents bundlers from trying to `import { useId } from 'react'`\nconst useId = react__WEBPACK_IMPORTED_MODULE_0__[\"useId\".toString()];\n\nconst PanelGroupContext = createContext(null);\nPanelGroupContext.displayName = \"PanelGroupContext\";\n\nconst wrappedUseId = typeof useId === \"function\" ? useId : () => null;\nlet counter = 0;\nfunction useUniqueId(idFromParams = null) {\n  const idFromUseId = wrappedUseId();\n  const idRef = useRef(idFromParams || idFromUseId || null);\n  if (idRef.current === null) {\n    idRef.current = \"\" + counter++;\n  }\n  return idFromParams !== null && idFromParams !== void 0 ? idFromParams : idRef.current;\n}\n\nfunction PanelWithForwardedRef({\n  children,\n  className: classNameFromProps = \"\",\n  collapsedSize,\n  collapsible,\n  defaultSize,\n  forwardedRef,\n  id: idFromProps,\n  maxSize,\n  minSize,\n  onCollapse,\n  onExpand,\n  onResize,\n  order,\n  style: styleFromProps,\n  tagName: Type = \"div\",\n  ...rest\n}) {\n  const context = useContext(PanelGroupContext);\n  if (context === null) {\n    throw Error(`Panel components must be rendered within a PanelGroup container`);\n  }\n  const {\n    collapsePanel,\n    expandPanel,\n    getPanelSize,\n    getPanelStyle,\n    groupId,\n    isPanelCollapsed,\n    reevaluatePanelConstraints,\n    registerPanel,\n    resizePanel,\n    unregisterPanel\n  } = context;\n  const panelId = useUniqueId(idFromProps);\n  const panelDataRef = useRef({\n    callbacks: {\n      onCollapse,\n      onExpand,\n      onResize\n    },\n    constraints: {\n      collapsedSize,\n      collapsible,\n      defaultSize,\n      maxSize,\n      minSize\n    },\n    id: panelId,\n    idIsFromProps: idFromProps !== undefined,\n    order\n  });\n  const devWarningsRef = useRef({\n    didLogMissingDefaultSizeWarning: false\n  });\n\n  // Normally we wouldn't log a warning during render,\n  // but effects don't run on the server, so we can't do it there\n  {\n    if (!devWarningsRef.current.didLogMissingDefaultSizeWarning) {\n      if (defaultSize == null) {\n        devWarningsRef.current.didLogMissingDefaultSizeWarning = true;\n        console.warn(`WARNING: Panel defaultSize prop recommended to avoid layout shift after server rendering`);\n      }\n    }\n  }\n  useImperativeHandle(forwardedRef, () => ({\n    collapse: () => {\n      collapsePanel(panelDataRef.current);\n    },\n    expand: () => {\n      expandPanel(panelDataRef.current);\n    },\n    getId() {\n      return panelId;\n    },\n    getSize() {\n      return getPanelSize(panelDataRef.current);\n    },\n    isCollapsed() {\n      return isPanelCollapsed(panelDataRef.current);\n    },\n    isExpanded() {\n      return !isPanelCollapsed(panelDataRef.current);\n    },\n    resize: size => {\n      resizePanel(panelDataRef.current, size);\n    }\n  }), [collapsePanel, expandPanel, getPanelSize, isPanelCollapsed, panelId, resizePanel]);\n  const style = getPanelStyle(panelDataRef.current, defaultSize);\n  return createElement(Type, {\n    ...rest,\n    children,\n    className: classNameFromProps,\n    id: idFromProps,\n    style: {\n      ...style,\n      ...styleFromProps\n    },\n    // CSS selectors\n    \"data-panel\": \"\",\n    \"data-panel-collapsible\": collapsible || undefined,\n    \"data-panel-group-id\": groupId,\n    \"data-panel-id\": panelId,\n    \"data-panel-size\": parseFloat(\"\" + style.flexGrow).toFixed(1)\n  });\n}\nconst Panel = forwardRef((props, ref) => createElement(PanelWithForwardedRef, {\n  ...props,\n  forwardedRef: ref\n}));\nPanelWithForwardedRef.displayName = \"Panel\";\nPanel.displayName = \"forwardRef(Panel)\";\n\nlet currentCursorStyle = null;\nlet styleElement = null;\nfunction getCursorStyle(state, constraintFlags) {\n  if (constraintFlags) {\n    const horizontalMin = (constraintFlags & EXCEEDED_HORIZONTAL_MIN) !== 0;\n    const horizontalMax = (constraintFlags & EXCEEDED_HORIZONTAL_MAX) !== 0;\n    const verticalMin = (constraintFlags & EXCEEDED_VERTICAL_MIN) !== 0;\n    const verticalMax = (constraintFlags & EXCEEDED_VERTICAL_MAX) !== 0;\n    if (horizontalMin) {\n      if (verticalMin) {\n        return \"se-resize\";\n      } else if (verticalMax) {\n        return \"ne-resize\";\n      } else {\n        return \"e-resize\";\n      }\n    } else if (horizontalMax) {\n      if (verticalMin) {\n        return \"sw-resize\";\n      } else if (verticalMax) {\n        return \"nw-resize\";\n      } else {\n        return \"w-resize\";\n      }\n    } else if (verticalMin) {\n      return \"s-resize\";\n    } else if (verticalMax) {\n      return \"n-resize\";\n    }\n  }\n  switch (state) {\n    case \"horizontal\":\n      return \"ew-resize\";\n    case \"intersection\":\n      return \"move\";\n    case \"vertical\":\n      return \"ns-resize\";\n  }\n}\nfunction resetGlobalCursorStyle() {\n  if (styleElement !== null) {\n    document.head.removeChild(styleElement);\n    currentCursorStyle = null;\n    styleElement = null;\n  }\n}\nfunction setGlobalCursorStyle(state, constraintFlags) {\n  const style = getCursorStyle(state, constraintFlags);\n  if (currentCursorStyle === style) {\n    return;\n  }\n  currentCursorStyle = style;\n  if (styleElement === null) {\n    styleElement = document.createElement(\"style\");\n    document.head.appendChild(styleElement);\n  }\n  styleElement.innerHTML = `*{cursor: ${style}!important;}`;\n}\n\nfunction isKeyDown(event) {\n  return event.type === \"keydown\";\n}\nfunction isMouseEvent(event) {\n  return event.type.startsWith(\"mouse\");\n}\nfunction isTouchEvent(event) {\n  return event.type.startsWith(\"touch\");\n}\n\nfunction getResizeEventCoordinates(event) {\n  if (isMouseEvent(event)) {\n    return {\n      x: event.clientX,\n      y: event.clientY\n    };\n  } else if (isTouchEvent(event)) {\n    const touch = event.touches[0];\n    if (touch && touch.clientX && touch.clientY) {\n      return {\n        x: touch.clientX,\n        y: touch.clientY\n      };\n    }\n  }\n  return {\n    x: Infinity,\n    y: Infinity\n  };\n}\n\nfunction getInputType() {\n  if (typeof matchMedia === \"function\") {\n    return matchMedia(\"(pointer:coarse)\").matches ? \"coarse\" : \"fine\";\n  }\n}\n\nfunction intersects(rectOne, rectTwo, strict) {\n  if (strict) {\n    return rectOne.x < rectTwo.x + rectTwo.width && rectOne.x + rectOne.width > rectTwo.x && rectOne.y < rectTwo.y + rectTwo.height && rectOne.y + rectOne.height > rectTwo.y;\n  } else {\n    return rectOne.x <= rectTwo.x + rectTwo.width && rectOne.x + rectOne.width >= rectTwo.x && rectOne.y <= rectTwo.y + rectTwo.height && rectOne.y + rectOne.height >= rectTwo.y;\n  }\n}\n\n// Forked from NPM stacking-order@2.0.0\n\n/**\n * Determine which of two nodes appears in front of the other â€”\n * if `a` is in front, returns 1, otherwise returns -1\n * @param {HTMLElement} a\n * @param {HTMLElement} b\n */\nfunction compare(a, b) {\n  if (a === b) throw new Error(\"Cannot compare node with itself\");\n  const ancestors = {\n    a: get_ancestors(a),\n    b: get_ancestors(b)\n  };\n  let common_ancestor;\n\n  // remove shared ancestors\n  while (ancestors.a.at(-1) === ancestors.b.at(-1)) {\n    a = ancestors.a.pop();\n    b = ancestors.b.pop();\n    common_ancestor = a;\n  }\n  assert(common_ancestor, \"Stacking order can only be calculated for elements with a common ancestor\");\n  const z_indexes = {\n    a: get_z_index(find_stacking_context(ancestors.a)),\n    b: get_z_index(find_stacking_context(ancestors.b))\n  };\n  if (z_indexes.a === z_indexes.b) {\n    const children = common_ancestor.childNodes;\n    const furthest_ancestors = {\n      a: ancestors.a.at(-1),\n      b: ancestors.b.at(-1)\n    };\n    let i = children.length;\n    while (i--) {\n      const child = children[i];\n      if (child === furthest_ancestors.a) return 1;\n      if (child === furthest_ancestors.b) return -1;\n    }\n  }\n  return Math.sign(z_indexes.a - z_indexes.b);\n}\nconst props = /\\b(?:position|zIndex|opacity|transform|webkitTransform|mixBlendMode|filter|webkitFilter|isolation)\\b/;\n\n/** @param {HTMLElement} node */\nfunction is_flex_item(node) {\n  const display = getComputedStyle(get_parent(node)).display;\n  return display === \"flex\" || display === \"inline-flex\";\n}\n\n/** @param {HTMLElement} node */\nfunction creates_stacking_context(node) {\n  const style = getComputedStyle(node);\n\n  // https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Positioning/Understanding_z_index/The_stacking_context\n  if (style.position === \"fixed\") return true;\n  // Forked to fix upstream bug https://github.com/Rich-Harris/stacking-order/issues/3\n  // if (\n  //   (style.zIndex !== \"auto\" && style.position !== \"static\") ||\n  //   is_flex_item(node)\n  // )\n  if (style.zIndex !== \"auto\" && (style.position !== \"static\" || is_flex_item(node))) return true;\n  if (+style.opacity < 1) return true;\n  if (\"transform\" in style && style.transform !== \"none\") return true;\n  if (\"webkitTransform\" in style && style.webkitTransform !== \"none\") return true;\n  if (\"mixBlendMode\" in style && style.mixBlendMode !== \"normal\") return true;\n  if (\"filter\" in style && style.filter !== \"none\") return true;\n  if (\"webkitFilter\" in style && style.webkitFilter !== \"none\") return true;\n  if (\"isolation\" in style && style.isolation === \"isolate\") return true;\n  if (props.test(style.willChange)) return true;\n  // @ts-expect-error\n  if (style.webkitOverflowScrolling === \"touch\") return true;\n  return false;\n}\n\n/** @param {HTMLElement[]} nodes */\nfunction find_stacking_context(nodes) {\n  let i = nodes.length;\n  while (i--) {\n    const node = nodes[i];\n    assert(node, \"Missing node\");\n    if (creates_stacking_context(node)) return node;\n  }\n  return null;\n}\n\n/** @param {HTMLElement} node */\nfunction get_z_index(node) {\n  return node && Number(getComputedStyle(node).zIndex) || 0;\n}\n\n/** @param {HTMLElement} node */\nfunction get_ancestors(node) {\n  const ancestors = [];\n  while (node) {\n    ancestors.push(node);\n    node = get_parent(node);\n  }\n  return ancestors; // [ node, ... <body>, <html>, document ]\n}\n\n/** @param {HTMLElement} node */\nfunction get_parent(node) {\n  var _node$parentNode;\n  // @ts-ignore\n  return ((_node$parentNode = node.parentNode) === null || _node$parentNode === void 0 ? void 0 : _node$parentNode.host) || node.parentNode;\n}\n\nconst EXCEEDED_HORIZONTAL_MIN = 0b0001;\nconst EXCEEDED_HORIZONTAL_MAX = 0b0010;\nconst EXCEEDED_VERTICAL_MIN = 0b0100;\nconst EXCEEDED_VERTICAL_MAX = 0b1000;\nconst isCoarsePointer = getInputType() === \"coarse\";\nlet intersectingHandles = [];\nlet isPointerDown = false;\nlet ownerDocumentCounts = new Map();\nlet panelConstraintFlags = new Map();\nconst registeredResizeHandlers = new Set();\nfunction registerResizeHandle(resizeHandleId, element, direction, hitAreaMargins, setResizeHandlerState) {\n  var _ownerDocumentCounts$;\n  const {\n    ownerDocument\n  } = element;\n  const data = {\n    direction,\n    element,\n    hitAreaMargins,\n    setResizeHandlerState\n  };\n  const count = (_ownerDocumentCounts$ = ownerDocumentCounts.get(ownerDocument)) !== null && _ownerDocumentCounts$ !== void 0 ? _ownerDocumentCounts$ : 0;\n  ownerDocumentCounts.set(ownerDocument, count + 1);\n  registeredResizeHandlers.add(data);\n  updateListeners();\n  return function unregisterResizeHandle() {\n    var _ownerDocumentCounts$2;\n    panelConstraintFlags.delete(resizeHandleId);\n    registeredResizeHandlers.delete(data);\n    const count = (_ownerDocumentCounts$2 = ownerDocumentCounts.get(ownerDocument)) !== null && _ownerDocumentCounts$2 !== void 0 ? _ownerDocumentCounts$2 : 1;\n    ownerDocumentCounts.set(ownerDocument, count - 1);\n    updateListeners();\n    if (count === 1) {\n      ownerDocumentCounts.delete(ownerDocument);\n    }\n  };\n}\nfunction handlePointerDown(event) {\n  const {\n    target\n  } = event;\n  const {\n    x,\n    y\n  } = getResizeEventCoordinates(event);\n  isPointerDown = true;\n  recalculateIntersectingHandles({\n    target,\n    x,\n    y\n  });\n  updateListeners();\n  if (intersectingHandles.length > 0) {\n    updateResizeHandlerStates(\"down\", event);\n    event.preventDefault();\n  }\n}\nfunction handlePointerMove(event) {\n  const {\n    x,\n    y\n  } = getResizeEventCoordinates(event);\n  if (!isPointerDown) {\n    const {\n      target\n    } = event;\n\n    // Recalculate intersecting handles whenever the pointer moves, except if it has already been pressed\n    // at that point, the handles may not move with the pointer (depending on constraints)\n    // but the same set of active handles should be locked until the pointer is released\n    recalculateIntersectingHandles({\n      target,\n      x,\n      y\n    });\n  }\n  updateResizeHandlerStates(\"move\", event);\n\n  // Update cursor based on return value(s) from active handles\n  updateCursor();\n  if (intersectingHandles.length > 0) {\n    event.preventDefault();\n  }\n}\nfunction handlePointerUp(event) {\n  const {\n    target\n  } = event;\n  const {\n    x,\n    y\n  } = getResizeEventCoordinates(event);\n  panelConstraintFlags.clear();\n  isPointerDown = false;\n  if (intersectingHandles.length > 0) {\n    event.preventDefault();\n  }\n  updateResizeHandlerStates(\"up\", event);\n  recalculateIntersectingHandles({\n    target,\n    x,\n    y\n  });\n  updateCursor();\n  updateListeners();\n}\nfunction recalculateIntersectingHandles({\n  target,\n  x,\n  y\n}) {\n  intersectingHandles.splice(0);\n  let targetElement = null;\n  if (target instanceof HTMLElement) {\n    targetElement = target;\n  }\n  registeredResizeHandlers.forEach(data => {\n    const {\n      element: dragHandleElement,\n      hitAreaMargins\n    } = data;\n    const dragHandleRect = dragHandleElement.getBoundingClientRect();\n    const {\n      bottom,\n      left,\n      right,\n      top\n    } = dragHandleRect;\n    const margin = isCoarsePointer ? hitAreaMargins.coarse : hitAreaMargins.fine;\n    const eventIntersects = x >= left - margin && x <= right + margin && y >= top - margin && y <= bottom + margin;\n    if (eventIntersects) {\n      // TRICKY\n      // We listen for pointers events at the root in order to support hit area margins\n      // (determining when the pointer is close enough to an element to be considered a \"hit\")\n      // Clicking on an element \"above\" a handle (e.g. a modal) should prevent a hit though\n      // so at this point we need to compare stacking order of a potentially intersecting drag handle,\n      // and the element that was actually clicked/touched\n      if (targetElement !== null && dragHandleElement !== targetElement && !dragHandleElement.contains(targetElement) && !targetElement.contains(dragHandleElement) &&\n      // Calculating stacking order has a cost, so we should avoid it if possible\n      // That is why we only check potentially intersecting handles,\n      // and why we skip if the event target is within the handle's DOM\n      compare(targetElement, dragHandleElement) > 0) {\n        // If the target is above the drag handle, then we also need to confirm they overlap\n        // If they are beside each other (e.g. a panel and its drag handle) then the handle is still interactive\n        //\n        // It's not enough to compare only the target\n        // The target might be a small element inside of a larger container\n        // (For example, a SPAN or a DIV inside of a larger modal dialog)\n        let currentElement = targetElement;\n        let didIntersect = false;\n        while (currentElement) {\n          if (currentElement.contains(dragHandleElement)) {\n            break;\n          } else if (intersects(currentElement.getBoundingClientRect(), dragHandleRect, true)) {\n            didIntersect = true;\n            break;\n          }\n          currentElement = currentElement.parentElement;\n        }\n        if (didIntersect) {\n          return;\n        }\n      }\n      intersectingHandles.push(data);\n    }\n  });\n}\nfunction reportConstraintsViolation(resizeHandleId, flag) {\n  panelConstraintFlags.set(resizeHandleId, flag);\n}\nfunction updateCursor() {\n  let intersectsHorizontal = false;\n  let intersectsVertical = false;\n  intersectingHandles.forEach(data => {\n    const {\n      direction\n    } = data;\n    if (direction === \"horizontal\") {\n      intersectsHorizontal = true;\n    } else {\n      intersectsVertical = true;\n    }\n  });\n  let constraintFlags = 0;\n  panelConstraintFlags.forEach(flag => {\n    constraintFlags |= flag;\n  });\n  if (intersectsHorizontal && intersectsVertical) {\n    setGlobalCursorStyle(\"intersection\", constraintFlags);\n  } else if (intersectsHorizontal) {\n    setGlobalCursorStyle(\"horizontal\", constraintFlags);\n  } else if (intersectsVertical) {\n    setGlobalCursorStyle(\"vertical\", constraintFlags);\n  } else {\n    resetGlobalCursorStyle();\n  }\n}\nfunction updateListeners() {\n  ownerDocumentCounts.forEach((_, ownerDocument) => {\n    const {\n      body\n    } = ownerDocument;\n    body.removeEventListener(\"contextmenu\", handlePointerUp);\n    body.removeEventListener(\"mousedown\", handlePointerDown);\n    body.removeEventListener(\"mouseleave\", handlePointerMove);\n    body.removeEventListener(\"mousemove\", handlePointerMove);\n    body.removeEventListener(\"touchmove\", handlePointerMove);\n    body.removeEventListener(\"touchstart\", handlePointerDown);\n  });\n  window.removeEventListener(\"mouseup\", handlePointerUp);\n  window.removeEventListener(\"touchcancel\", handlePointerUp);\n  window.removeEventListener(\"touchend\", handlePointerUp);\n  if (registeredResizeHandlers.size > 0) {\n    if (isPointerDown) {\n      if (intersectingHandles.length > 0) {\n        ownerDocumentCounts.forEach((count, ownerDocument) => {\n          const {\n            body\n          } = ownerDocument;\n          if (count > 0) {\n            body.addEventListener(\"contextmenu\", handlePointerUp);\n            body.addEventListener(\"mouseleave\", handlePointerMove);\n            body.addEventListener(\"mousemove\", handlePointerMove);\n            body.addEventListener(\"touchmove\", handlePointerMove, {\n              passive: false\n            });\n          }\n        });\n      }\n      window.addEventListener(\"mouseup\", handlePointerUp);\n      window.addEventListener(\"touchcancel\", handlePointerUp);\n      window.addEventListener(\"touchend\", handlePointerUp);\n    } else {\n      ownerDocumentCounts.forEach((count, ownerDocument) => {\n        const {\n          body\n        } = ownerDocument;\n        if (count > 0) {\n          body.addEventListener(\"mousedown\", handlePointerDown);\n          body.addEventListener(\"mousemove\", handlePointerMove);\n          body.addEventListener(\"touchmove\", handlePointerMove, {\n            passive: false\n          });\n          body.addEventListener(\"touchstart\", handlePointerDown);\n        }\n      });\n    }\n  }\n}\nfunction updateResizeHandlerStates(action, event) {\n  registeredResizeHandlers.forEach(data => {\n    const {\n      setResizeHandlerState\n    } = data;\n    const isActive = intersectingHandles.includes(data);\n    setResizeHandlerState(action, isActive, event);\n  });\n}\n\nfunction assert(expectedCondition, message) {\n  if (!expectedCondition) {\n    console.error(message);\n    throw Error(message);\n  }\n}\n\nconst PRECISION = 10;\n\nfunction fuzzyCompareNumbers(actual, expected, fractionDigits = PRECISION) {\n  actual = parseFloat(actual.toFixed(fractionDigits));\n  expected = parseFloat(expected.toFixed(fractionDigits));\n  const delta = actual - expected;\n  if (delta === 0) {\n    return 0;\n  } else {\n    return delta > 0 ? 1 : -1;\n  }\n}\n\nfunction fuzzyNumbersEqual(actual, expected, fractionDigits) {\n  return fuzzyCompareNumbers(actual, expected, fractionDigits) === 0;\n}\n\nfunction fuzzyLayoutsEqual(actual, expected, fractionDigits) {\n  if (actual.length !== expected.length) {\n    return false;\n  }\n  for (let index = 0; index < actual.length; index++) {\n    const actualSize = actual[index];\n    const expectedSize = expected[index];\n    if (!fuzzyNumbersEqual(actualSize, expectedSize, fractionDigits)) {\n      return false;\n    }\n  }\n  return true;\n}\n\n// Panel size must be in percentages; pixel values should be pre-converted\nfunction resizePanel({\n  panelConstraints: panelConstraintsArray,\n  panelIndex,\n  size\n}) {\n  const panelConstraints = panelConstraintsArray[panelIndex];\n  assert(panelConstraints != null, `Panel constraints not found for index ${panelIndex}`);\n  let {\n    collapsedSize = 0,\n    collapsible,\n    maxSize = 100,\n    minSize = 0\n  } = panelConstraints;\n  if (fuzzyCompareNumbers(size, minSize) < 0) {\n    if (collapsible) {\n      // Collapsible panels should snap closed or open only once they cross the halfway point between collapsed and min size.\n      const halfwayPoint = (collapsedSize + minSize) / 2;\n      if (fuzzyCompareNumbers(size, halfwayPoint) < 0) {\n        size = collapsedSize;\n      } else {\n        size = minSize;\n      }\n    } else {\n      size = minSize;\n    }\n  }\n  size = Math.min(maxSize, size);\n  size = parseFloat(size.toFixed(PRECISION));\n  return size;\n}\n\n// All units must be in percentages; pixel values should be pre-converted\nfunction adjustLayoutByDelta({\n  delta,\n  initialLayout,\n  panelConstraints: panelConstraintsArray,\n  pivotIndices,\n  prevLayout,\n  trigger\n}) {\n  if (fuzzyNumbersEqual(delta, 0)) {\n    return initialLayout;\n  }\n  const nextLayout = [...initialLayout];\n  const [firstPivotIndex, secondPivotIndex] = pivotIndices;\n  assert(firstPivotIndex != null, \"Invalid first pivot index\");\n  assert(secondPivotIndex != null, \"Invalid second pivot index\");\n  let deltaApplied = 0;\n\n  // const DEBUG = [];\n  // DEBUG.push(`adjustLayoutByDelta()`);\n  // DEBUG.push(`  initialLayout: ${initialLayout.join(\", \")}`);\n  // DEBUG.push(`  prevLayout: ${prevLayout.join(\", \")}`);\n  // DEBUG.push(`  delta: ${delta}`);\n  // DEBUG.push(`  pivotIndices: ${pivotIndices.join(\", \")}`);\n  // DEBUG.push(`  trigger: ${trigger}`);\n  // DEBUG.push(\"\");\n\n  // A resizing panel affects the panels before or after it.\n  //\n  // A negative delta means the panel(s) immediately after the resize handle should grow/expand by decreasing its offset.\n  // Other panels may also need to shrink/contract (and shift) to make room, depending on the min weights.\n  //\n  // A positive delta means the panel(s) immediately before the resize handle should \"expand\".\n  // This is accomplished by shrinking/contracting (and shifting) one or more of the panels after the resize handle.\n\n  {\n    // If this is a resize triggered by a keyboard event, our logic for expanding/collapsing is different.\n    // We no longer check the halfway threshold because this may prevent the panel from expanding at all.\n    if (trigger === \"keyboard\") {\n      {\n        // Check if we should expand a collapsed panel\n        const index = delta < 0 ? secondPivotIndex : firstPivotIndex;\n        const panelConstraints = panelConstraintsArray[index];\n        assert(panelConstraints, `Panel constraints not found for index ${index}`);\n        const {\n          collapsedSize = 0,\n          collapsible,\n          minSize = 0\n        } = panelConstraints;\n\n        // DEBUG.push(`edge case check 1: ${index}`);\n        // DEBUG.push(`  -> collapsible? ${collapsible}`);\n        if (collapsible) {\n          const prevSize = initialLayout[index];\n          assert(prevSize != null, `Previous layout not found for panel index ${index}`);\n          if (fuzzyNumbersEqual(prevSize, collapsedSize)) {\n            const localDelta = minSize - prevSize;\n            // DEBUG.push(`  -> expand delta: ${localDelta}`);\n\n            if (fuzzyCompareNumbers(localDelta, Math.abs(delta)) > 0) {\n              delta = delta < 0 ? 0 - localDelta : localDelta;\n              // DEBUG.push(`  -> delta: ${delta}`);\n            }\n          }\n        }\n      }\n\n      {\n        // Check if we should collapse a panel at its minimum size\n        const index = delta < 0 ? firstPivotIndex : secondPivotIndex;\n        const panelConstraints = panelConstraintsArray[index];\n        assert(panelConstraints, `No panel constraints found for index ${index}`);\n        const {\n          collapsedSize = 0,\n          collapsible,\n          minSize = 0\n        } = panelConstraints;\n\n        // DEBUG.push(`edge case check 2: ${index}`);\n        // DEBUG.push(`  -> collapsible? ${collapsible}`);\n        if (collapsible) {\n          const prevSize = initialLayout[index];\n          assert(prevSize != null, `Previous layout not found for panel index ${index}`);\n          if (fuzzyNumbersEqual(prevSize, minSize)) {\n            const localDelta = prevSize - collapsedSize;\n            // DEBUG.push(`  -> expand delta: ${localDelta}`);\n\n            if (fuzzyCompareNumbers(localDelta, Math.abs(delta)) > 0) {\n              delta = delta < 0 ? 0 - localDelta : localDelta;\n              // DEBUG.push(`  -> delta: ${delta}`);\n            }\n          }\n        }\n      }\n    }\n    // DEBUG.push(\"\");\n  }\n\n  {\n    // Pre-calculate max available delta in the opposite direction of our pivot.\n    // This will be the maximum amount we're allowed to expand/contract the panels in the primary direction.\n    // If this amount is less than the requested delta, adjust the requested delta.\n    // If this amount is greater than the requested delta, that's useful information tooâ€“\n    // as an expanding panel might change from collapsed to min size.\n\n    const increment = delta < 0 ? 1 : -1;\n    let index = delta < 0 ? secondPivotIndex : firstPivotIndex;\n    let maxAvailableDelta = 0;\n\n    // DEBUG.push(\"pre calc...\");\n    while (true) {\n      const prevSize = initialLayout[index];\n      assert(prevSize != null, `Previous layout not found for panel index ${index}`);\n      const maxSafeSize = resizePanel({\n        panelConstraints: panelConstraintsArray,\n        panelIndex: index,\n        size: 100\n      });\n      const delta = maxSafeSize - prevSize;\n      // DEBUG.push(`  ${index}: ${prevSize} -> ${maxSafeSize}`);\n\n      maxAvailableDelta += delta;\n      index += increment;\n      if (index < 0 || index >= panelConstraintsArray.length) {\n        break;\n      }\n    }\n\n    // DEBUG.push(`  -> max available delta: ${maxAvailableDelta}`);\n    const minAbsDelta = Math.min(Math.abs(delta), Math.abs(maxAvailableDelta));\n    delta = delta < 0 ? 0 - minAbsDelta : minAbsDelta;\n    // DEBUG.push(`  -> adjusted delta: ${delta}`);\n    // DEBUG.push(\"\");\n  }\n\n  {\n    // Delta added to a panel needs to be subtracted from other panels (within the constraints that those panels allow).\n\n    const pivotIndex = delta < 0 ? firstPivotIndex : secondPivotIndex;\n    let index = pivotIndex;\n    while (index >= 0 && index < panelConstraintsArray.length) {\n      const deltaRemaining = Math.abs(delta) - Math.abs(deltaApplied);\n      const prevSize = initialLayout[index];\n      assert(prevSize != null, `Previous layout not found for panel index ${index}`);\n      const unsafeSize = prevSize - deltaRemaining;\n      const safeSize = resizePanel({\n        panelConstraints: panelConstraintsArray,\n        panelIndex: index,\n        size: unsafeSize\n      });\n      if (!fuzzyNumbersEqual(prevSize, safeSize)) {\n        deltaApplied += prevSize - safeSize;\n        nextLayout[index] = safeSize;\n        if (deltaApplied.toPrecision(3).localeCompare(Math.abs(delta).toPrecision(3), undefined, {\n          numeric: true\n        }) >= 0) {\n          break;\n        }\n      }\n      if (delta < 0) {\n        index--;\n      } else {\n        index++;\n      }\n    }\n  }\n  // DEBUG.push(`after 1: ${nextLayout.join(\", \")}`);\n  // DEBUG.push(`  deltaApplied: ${deltaApplied}`);\n  // DEBUG.push(\"\");\n\n  // If we were unable to resize any of the panels panels, return the previous state.\n  // This will essentially bailout and ignore e.g. drags past a panel's boundaries\n  if (fuzzyLayoutsEqual(prevLayout, nextLayout)) {\n    // DEBUG.push(`bailout to previous layout: ${prevLayout.join(\", \")}`);\n    // console.log(DEBUG.join(\"\\n\"));\n\n    return prevLayout;\n  }\n  {\n    // Now distribute the applied delta to the panels in the other direction\n    const pivotIndex = delta < 0 ? secondPivotIndex : firstPivotIndex;\n    const prevSize = initialLayout[pivotIndex];\n    assert(prevSize != null, `Previous layout not found for panel index ${pivotIndex}`);\n    const unsafeSize = prevSize + deltaApplied;\n    const safeSize = resizePanel({\n      panelConstraints: panelConstraintsArray,\n      panelIndex: pivotIndex,\n      size: unsafeSize\n    });\n\n    // Adjust the pivot panel before, but only by the amount that surrounding panels were able to shrink/contract.\n    nextLayout[pivotIndex] = safeSize;\n\n    // Edge case where expanding or contracting one panel caused another one to change collapsed state\n    if (!fuzzyNumbersEqual(safeSize, unsafeSize)) {\n      let deltaRemaining = unsafeSize - safeSize;\n      const pivotIndex = delta < 0 ? secondPivotIndex : firstPivotIndex;\n      let index = pivotIndex;\n      while (index >= 0 && index < panelConstraintsArray.length) {\n        const prevSize = nextLayout[index];\n        assert(prevSize != null, `Previous layout not found for panel index ${index}`);\n        const unsafeSize = prevSize + deltaRemaining;\n        const safeSize = resizePanel({\n          panelConstraints: panelConstraintsArray,\n          panelIndex: index,\n          size: unsafeSize\n        });\n        if (!fuzzyNumbersEqual(prevSize, safeSize)) {\n          deltaRemaining -= safeSize - prevSize;\n          nextLayout[index] = safeSize;\n        }\n        if (fuzzyNumbersEqual(deltaRemaining, 0)) {\n          break;\n        }\n        if (delta > 0) {\n          index--;\n        } else {\n          index++;\n        }\n      }\n    }\n  }\n  // DEBUG.push(`after 2: ${nextLayout.join(\", \")}`);\n  // DEBUG.push(`  deltaApplied: ${deltaApplied}`);\n  // DEBUG.push(\"\");\n\n  const totalSize = nextLayout.reduce((total, size) => size + total, 0);\n  // DEBUG.push(`total size: ${totalSize}`);\n\n  // If our new layout doesn't add up to 100%, that means the requested delta can't be applied\n  // In that case, fall back to our most recent valid layout\n  if (!fuzzyNumbersEqual(totalSize, 100)) {\n    // DEBUG.push(`bailout to previous layout: ${prevLayout.join(\", \")}`);\n    // console.log(DEBUG.join(\"\\n\"));\n\n    return prevLayout;\n  }\n\n  // console.log(DEBUG.join(\"\\n\"));\n  return nextLayout;\n}\n\nfunction getResizeHandleElementsForGroup(groupId, scope = document) {\n  return Array.from(scope.querySelectorAll(`[data-panel-resize-handle-id][data-panel-group-id=\"${groupId}\"]`));\n}\n\nfunction getResizeHandleElementIndex(groupId, id, scope = document) {\n  const handles = getResizeHandleElementsForGroup(groupId, scope);\n  const index = handles.findIndex(handle => handle.getAttribute(\"data-panel-resize-handle-id\") === id);\n  return index !== null && index !== void 0 ? index : null;\n}\n\nfunction determinePivotIndices(groupId, dragHandleId, panelGroupElement) {\n  const index = getResizeHandleElementIndex(groupId, dragHandleId, panelGroupElement);\n  return index != null ? [index, index + 1] : [-1, -1];\n}\n\nfunction getPanelGroupElement(id, rootElement = document) {\n  var _dataset;\n  //If the root element is the PanelGroup\n  if (rootElement instanceof HTMLElement && (rootElement === null || rootElement === void 0 ? void 0 : (_dataset = rootElement.dataset) === null || _dataset === void 0 ? void 0 : _dataset.panelGroupId) == id) {\n    return rootElement;\n  }\n\n  //Else query children\n  const element = rootElement.querySelector(`[data-panel-group][data-panel-group-id=\"${id}\"]`);\n  if (element) {\n    return element;\n  }\n  return null;\n}\n\nfunction getResizeHandleElement(id, scope = document) {\n  const element = scope.querySelector(`[data-panel-resize-handle-id=\"${id}\"]`);\n  if (element) {\n    return element;\n  }\n  return null;\n}\n\nfunction getResizeHandlePanelIds(groupId, handleId, panelsArray, scope = document) {\n  var _panelsArray$index$id, _panelsArray$index, _panelsArray$id, _panelsArray;\n  const handle = getResizeHandleElement(handleId, scope);\n  const handles = getResizeHandleElementsForGroup(groupId, scope);\n  const index = handle ? handles.indexOf(handle) : -1;\n  const idBefore = (_panelsArray$index$id = (_panelsArray$index = panelsArray[index]) === null || _panelsArray$index === void 0 ? void 0 : _panelsArray$index.id) !== null && _panelsArray$index$id !== void 0 ? _panelsArray$index$id : null;\n  const idAfter = (_panelsArray$id = (_panelsArray = panelsArray[index + 1]) === null || _panelsArray === void 0 ? void 0 : _panelsArray.id) !== null && _panelsArray$id !== void 0 ? _panelsArray$id : null;\n  return [idBefore, idAfter];\n}\n\n// https://www.w3.org/WAI/ARIA/apg/patterns/windowsplitter/\n\nfunction useWindowSplitterPanelGroupBehavior({\n  committedValuesRef,\n  eagerValuesRef,\n  groupId,\n  layout,\n  panelDataArray,\n  panelGroupElement,\n  setLayout\n}) {\n  useRef({\n    didWarnAboutMissingResizeHandle: false\n  });\n  useEffect(() => {\n    if (!panelGroupElement) {\n      return;\n    }\n    const eagerValues = eagerValuesRef.current;\n    assert(eagerValues, `Eager values not found`);\n    const {\n      panelDataArray\n    } = eagerValues;\n    const groupElement = getPanelGroupElement(groupId, panelGroupElement);\n    assert(groupElement != null, `No group found for id \"${groupId}\"`);\n    const handles = getResizeHandleElementsForGroup(groupId, panelGroupElement);\n    assert(handles, `No resize handles found for group id \"${groupId}\"`);\n    const cleanupFunctions = handles.map(handle => {\n      const handleId = handle.getAttribute(\"data-panel-resize-handle-id\");\n      assert(handleId, `Resize handle element has no handle id attribute`);\n      const [idBefore, idAfter] = getResizeHandlePanelIds(groupId, handleId, panelDataArray, panelGroupElement);\n      if (idBefore == null || idAfter == null) {\n        return () => {};\n      }\n      const onKeyDown = event => {\n        if (event.defaultPrevented) {\n          return;\n        }\n        switch (event.key) {\n          case \"Enter\":\n            {\n              event.preventDefault();\n              const index = panelDataArray.findIndex(panelData => panelData.id === idBefore);\n              if (index >= 0) {\n                const panelData = panelDataArray[index];\n                assert(panelData, `No panel data found for index ${index}`);\n                const size = layout[index];\n                const {\n                  collapsedSize = 0,\n                  collapsible,\n                  minSize = 0\n                } = panelData.constraints;\n                if (size != null && collapsible) {\n                  const nextLayout = adjustLayoutByDelta({\n                    delta: fuzzyNumbersEqual(size, collapsedSize) ? minSize - collapsedSize : collapsedSize - size,\n                    initialLayout: layout,\n                    panelConstraints: panelDataArray.map(panelData => panelData.constraints),\n                    pivotIndices: determinePivotIndices(groupId, handleId, panelGroupElement),\n                    prevLayout: layout,\n                    trigger: \"keyboard\"\n                  });\n                  if (layout !== nextLayout) {\n                    setLayout(nextLayout);\n                  }\n                }\n              }\n              break;\n            }\n        }\n      };\n      handle.addEventListener(\"keydown\", onKeyDown);\n      return () => {\n        handle.removeEventListener(\"keydown\", onKeyDown);\n      };\n    });\n    return () => {\n      cleanupFunctions.forEach(cleanupFunction => cleanupFunction());\n    };\n  }, [panelGroupElement, committedValuesRef, eagerValuesRef, groupId, layout, panelDataArray, setLayout]);\n}\n\nfunction areEqual(arrayA, arrayB) {\n  if (arrayA.length !== arrayB.length) {\n    return false;\n  }\n  for (let index = 0; index < arrayA.length; index++) {\n    if (arrayA[index] !== arrayB[index]) {\n      return false;\n    }\n  }\n  return true;\n}\n\nfunction getResizeEventCursorPosition(direction, event) {\n  const isHorizontal = direction === \"horizontal\";\n  const {\n    x,\n    y\n  } = getResizeEventCoordinates(event);\n  return isHorizontal ? x : y;\n}\n\nfunction calculateDragOffsetPercentage(event, dragHandleId, direction, initialDragState, panelGroupElement) {\n  const isHorizontal = direction === \"horizontal\";\n  const handleElement = getResizeHandleElement(dragHandleId, panelGroupElement);\n  assert(handleElement, `No resize handle element found for id \"${dragHandleId}\"`);\n  const groupId = handleElement.getAttribute(\"data-panel-group-id\");\n  assert(groupId, `Resize handle element has no group id attribute`);\n  let {\n    initialCursorPosition\n  } = initialDragState;\n  const cursorPosition = getResizeEventCursorPosition(direction, event);\n  const groupElement = getPanelGroupElement(groupId, panelGroupElement);\n  assert(groupElement, `No group element found for id \"${groupId}\"`);\n  const groupRect = groupElement.getBoundingClientRect();\n  const groupSizeInPixels = isHorizontal ? groupRect.width : groupRect.height;\n  const offsetPixels = cursorPosition - initialCursorPosition;\n  const offsetPercentage = offsetPixels / groupSizeInPixels * 100;\n  return offsetPercentage;\n}\n\n// https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/movementX\nfunction calculateDeltaPercentage(event, dragHandleId, direction, initialDragState, keyboardResizeBy, panelGroupElement) {\n  if (isKeyDown(event)) {\n    const isHorizontal = direction === \"horizontal\";\n    let delta = 0;\n    if (event.shiftKey) {\n      delta = 100;\n    } else if (keyboardResizeBy != null) {\n      delta = keyboardResizeBy;\n    } else {\n      delta = 10;\n    }\n    let movement = 0;\n    switch (event.key) {\n      case \"ArrowDown\":\n        movement = isHorizontal ? 0 : delta;\n        break;\n      case \"ArrowLeft\":\n        movement = isHorizontal ? -delta : 0;\n        break;\n      case \"ArrowRight\":\n        movement = isHorizontal ? delta : 0;\n        break;\n      case \"ArrowUp\":\n        movement = isHorizontal ? 0 : -delta;\n        break;\n      case \"End\":\n        movement = 100;\n        break;\n      case \"Home\":\n        movement = -100;\n        break;\n    }\n    return movement;\n  } else {\n    if (initialDragState == null) {\n      return 0;\n    }\n    return calculateDragOffsetPercentage(event, dragHandleId, direction, initialDragState, panelGroupElement);\n  }\n}\n\n// Layout should be pre-converted into percentages\nfunction callPanelCallbacks(panelsArray, layout, panelIdToLastNotifiedSizeMap) {\n  layout.forEach((size, index) => {\n    const panelData = panelsArray[index];\n    assert(panelData, `Panel data not found for index ${index}`);\n    const {\n      callbacks,\n      constraints,\n      id: panelId\n    } = panelData;\n    const {\n      collapsedSize = 0,\n      collapsible\n    } = constraints;\n    const lastNotifiedSize = panelIdToLastNotifiedSizeMap[panelId];\n    if (lastNotifiedSize == null || size !== lastNotifiedSize) {\n      panelIdToLastNotifiedSizeMap[panelId] = size;\n      const {\n        onCollapse,\n        onExpand,\n        onResize\n      } = callbacks;\n      if (onResize) {\n        onResize(size, lastNotifiedSize);\n      }\n      if (collapsible && (onCollapse || onExpand)) {\n        if (onExpand && (lastNotifiedSize == null || lastNotifiedSize === collapsedSize) && size !== collapsedSize) {\n          onExpand();\n        }\n        if (onCollapse && (lastNotifiedSize == null || lastNotifiedSize !== collapsedSize) && size === collapsedSize) {\n          onCollapse();\n        }\n      }\n    }\n  });\n}\n\nfunction compareLayouts(a, b) {\n  if (a.length !== b.length) {\n    return false;\n  } else {\n    for (let index = 0; index < a.length; index++) {\n      if (a[index] != b[index]) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\n\n// This method returns a number between 1 and 100 representing\n\n// the % of the group's overall space this panel should occupy.\nfunction computePanelFlexBoxStyle({\n  defaultSize,\n  dragState,\n  layout,\n  panelData,\n  panelIndex,\n  precision = 3\n}) {\n  const size = layout[panelIndex];\n  let flexGrow;\n  if (size == null) {\n    // Initial render (before panels have registered themselves)\n    // In order to support server rendering, fall back to default size if provided\n    flexGrow = defaultSize != undefined ? defaultSize.toPrecision(precision) : \"1\";\n  } else if (panelData.length === 1) {\n    // Special case: Single panel group should always fill full width/height\n    flexGrow = \"1\";\n  } else {\n    flexGrow = size.toPrecision(precision);\n  }\n  return {\n    flexBasis: 0,\n    flexGrow,\n    flexShrink: 1,\n    // Without this, Panel sizes may be unintentionally overridden by their content\n    overflow: \"hidden\",\n    // Disable pointer events inside of a panel during resize\n    // This avoid edge cases like nested iframes\n    pointerEvents: dragState !== null ? \"none\" : undefined\n  };\n}\n\nfunction debounce(callback, durationMs = 10) {\n  let timeoutId = null;\n  let callable = (...args) => {\n    if (timeoutId !== null) {\n      clearTimeout(timeoutId);\n    }\n    timeoutId = setTimeout(() => {\n      callback(...args);\n    }, durationMs);\n  };\n  return callable;\n}\n\n// PanelGroup might be rendering in a server-side environment where localStorage is not available\n// or on a browser with cookies/storage disabled.\n// In either case, this function avoids accessing localStorage until needed,\n// and avoids throwing user-visible errors.\nfunction initializeDefaultStorage(storageObject) {\n  try {\n    if (typeof localStorage !== \"undefined\") {\n      // Bypass this check for future calls\n      storageObject.getItem = name => {\n        return localStorage.getItem(name);\n      };\n      storageObject.setItem = (name, value) => {\n        localStorage.setItem(name, value);\n      };\n    } else {\n      throw new Error(\"localStorage not supported in this environment\");\n    }\n  } catch (error) {\n    console.error(error);\n    storageObject.getItem = () => null;\n    storageObject.setItem = () => {};\n  }\n}\n\nfunction getPanelGroupKey(autoSaveId) {\n  return `react-resizable-panels:${autoSaveId}`;\n}\n\n// Note that Panel ids might be user-provided (stable) or useId generated (non-deterministic)\n// so they should not be used as part of the serialization key.\n// Using the min/max size attributes should work well enough as a backup.\n// Pre-sorting by minSize allows remembering layouts even if panels are re-ordered/dragged.\nfunction getPanelKey(panels) {\n  return panels.map(panel => {\n    const {\n      constraints,\n      id,\n      idIsFromProps,\n      order\n    } = panel;\n    if (idIsFromProps) {\n      return id;\n    } else {\n      return order ? `${order}:${JSON.stringify(constraints)}` : JSON.stringify(constraints);\n    }\n  }).sort((a, b) => a.localeCompare(b)).join(\",\");\n}\nfunction loadSerializedPanelGroupState(autoSaveId, storage) {\n  try {\n    const panelGroupKey = getPanelGroupKey(autoSaveId);\n    const serialized = storage.getItem(panelGroupKey);\n    if (serialized) {\n      const parsed = JSON.parse(serialized);\n      if (typeof parsed === \"object\" && parsed != null) {\n        return parsed;\n      }\n    }\n  } catch (error) {}\n  return null;\n}\nfunction savePanelGroupState(autoSaveId, panels, panelSizesBeforeCollapse, sizes, storage) {\n  var _loadSerializedPanelG2;\n  const panelGroupKey = getPanelGroupKey(autoSaveId);\n  const panelKey = getPanelKey(panels);\n  const state = (_loadSerializedPanelG2 = loadSerializedPanelGroupState(autoSaveId, storage)) !== null && _loadSerializedPanelG2 !== void 0 ? _loadSerializedPanelG2 : {};\n  state[panelKey] = {\n    expandToSizes: Object.fromEntries(panelSizesBeforeCollapse.entries()),\n    layout: sizes\n  };\n  try {\n    storage.setItem(panelGroupKey, JSON.stringify(state));\n  } catch (error) {\n    console.error(error);\n  }\n}\n\nfunction validatePanelConstraints({\n  panelConstraints: panelConstraintsArray,\n  panelId,\n  panelIndex\n}) {\n  {\n    const warnings = [];\n    const panelConstraints = panelConstraintsArray[panelIndex];\n    assert(panelConstraints, `No panel constraints found for index ${panelIndex}`);\n    const {\n      collapsedSize = 0,\n      collapsible = false,\n      defaultSize,\n      maxSize = 100,\n      minSize = 0\n    } = panelConstraints;\n    if (minSize > maxSize) {\n      warnings.push(`min size (${minSize}%) should not be greater than max size (${maxSize}%)`);\n    }\n    if (defaultSize != null) {\n      if (defaultSize < 0) {\n        warnings.push(\"default size should not be less than 0\");\n      } else if (defaultSize < minSize && (!collapsible || defaultSize !== collapsedSize)) {\n        warnings.push(\"default size should not be less than min size\");\n      }\n      if (defaultSize > 100) {\n        warnings.push(\"default size should not be greater than 100\");\n      } else if (defaultSize > maxSize) {\n        warnings.push(\"default size should not be greater than max size\");\n      }\n    }\n    if (collapsedSize > minSize) {\n      warnings.push(\"collapsed size should not be greater than min size\");\n    }\n    if (warnings.length > 0) {\n      const name = panelId != null ? `Panel \"${panelId}\"` : \"Panel\";\n      console.warn(`${name} has an invalid configuration:\\n\\n${warnings.join(\"\\n\")}`);\n      return false;\n    }\n  }\n  return true;\n}\n\n// All units must be in percentages; pixel values should be pre-converted\nfunction validatePanelGroupLayout({\n  layout: prevLayout,\n  panelConstraints\n}) {\n  const nextLayout = [...prevLayout];\n  const nextLayoutTotalSize = nextLayout.reduce((accumulated, current) => accumulated + current, 0);\n\n  // Validate layout expectations\n  if (nextLayout.length !== panelConstraints.length) {\n    throw Error(`Invalid ${panelConstraints.length} panel layout: ${nextLayout.map(size => `${size}%`).join(\", \")}`);\n  } else if (!fuzzyNumbersEqual(nextLayoutTotalSize, 100)) {\n    // This is not ideal so we should warn about it, but it may be recoverable in some cases\n    // (especially if the amount is small)\n    {\n      console.warn(`WARNING: Invalid layout total size: ${nextLayout.map(size => `${size}%`).join(\", \")}. Layout normalization will be applied.`);\n    }\n    for (let index = 0; index < panelConstraints.length; index++) {\n      const unsafeSize = nextLayout[index];\n      assert(unsafeSize != null, `No layout data found for index ${index}`);\n      const safeSize = 100 / nextLayoutTotalSize * unsafeSize;\n      nextLayout[index] = safeSize;\n    }\n  }\n  let remainingSize = 0;\n\n  // First pass: Validate the proposed layout given each panel's constraints\n  for (let index = 0; index < panelConstraints.length; index++) {\n    const unsafeSize = nextLayout[index];\n    assert(unsafeSize != null, `No layout data found for index ${index}`);\n    const safeSize = resizePanel({\n      panelConstraints,\n      panelIndex: index,\n      size: unsafeSize\n    });\n    if (unsafeSize != safeSize) {\n      remainingSize += unsafeSize - safeSize;\n      nextLayout[index] = safeSize;\n    }\n  }\n\n  // If there is additional, left over space, assign it to any panel(s) that permits it\n  // (It's not worth taking multiple additional passes to evenly distribute)\n  if (!fuzzyNumbersEqual(remainingSize, 0)) {\n    for (let index = 0; index < panelConstraints.length; index++) {\n      const prevSize = nextLayout[index];\n      assert(prevSize != null, `No layout data found for index ${index}`);\n      const unsafeSize = prevSize + remainingSize;\n      const safeSize = resizePanel({\n        panelConstraints,\n        panelIndex: index,\n        size: unsafeSize\n      });\n      if (prevSize !== safeSize) {\n        remainingSize -= safeSize - prevSize;\n        nextLayout[index] = safeSize;\n\n        // Once we've used up the remainder, bail\n        if (fuzzyNumbersEqual(remainingSize, 0)) {\n          break;\n        }\n      }\n    }\n  }\n  return nextLayout;\n}\n\nconst LOCAL_STORAGE_DEBOUNCE_INTERVAL = 100;\nconst defaultStorage = {\n  getItem: name => {\n    initializeDefaultStorage(defaultStorage);\n    return defaultStorage.getItem(name);\n  },\n  setItem: (name, value) => {\n    initializeDefaultStorage(defaultStorage);\n    defaultStorage.setItem(name, value);\n  }\n};\nconst debounceMap = {};\nfunction PanelGroupWithForwardedRef({\n  autoSaveId = null,\n  children,\n  className: classNameFromProps = \"\",\n  direction,\n  forwardedRef,\n  id: idFromProps = null,\n  onLayout = null,\n  keyboardResizeBy = null,\n  storage = defaultStorage,\n  style: styleFromProps,\n  tagName: Type = \"div\",\n  ...rest\n}) {\n  const groupId = useUniqueId(idFromProps);\n  const panelGroupElementRef = useRef(null);\n  const [dragState, setDragState] = useState(null);\n  const [layout, setLayout] = useState([]);\n  const panelIdToLastNotifiedSizeMapRef = useRef({});\n  const panelSizeBeforeCollapseRef = useRef(new Map());\n  const prevDeltaRef = useRef(0);\n  const committedValuesRef = useRef({\n    autoSaveId,\n    direction,\n    dragState,\n    id: groupId,\n    keyboardResizeBy,\n    onLayout,\n    storage\n  });\n  const eagerValuesRef = useRef({\n    layout,\n    panelDataArray: [],\n    panelDataArrayChanged: false\n  });\n  const devWarningsRef = useRef({\n    didLogIdAndOrderWarning: false,\n    didLogPanelConstraintsWarning: false,\n    prevPanelIds: []\n  });\n  useImperativeHandle(forwardedRef, () => ({\n    getId: () => committedValuesRef.current.id,\n    getLayout: () => {\n      const {\n        layout\n      } = eagerValuesRef.current;\n      return layout;\n    },\n    setLayout: unsafeLayout => {\n      const {\n        onLayout\n      } = committedValuesRef.current;\n      const {\n        layout: prevLayout,\n        panelDataArray\n      } = eagerValuesRef.current;\n      const safeLayout = validatePanelGroupLayout({\n        layout: unsafeLayout,\n        panelConstraints: panelDataArray.map(panelData => panelData.constraints)\n      });\n      if (!areEqual(prevLayout, safeLayout)) {\n        setLayout(safeLayout);\n        eagerValuesRef.current.layout = safeLayout;\n        if (onLayout) {\n          onLayout(safeLayout);\n        }\n        callPanelCallbacks(panelDataArray, safeLayout, panelIdToLastNotifiedSizeMapRef.current);\n      }\n    }\n  }), []);\n  useWindowSplitterPanelGroupBehavior({\n    committedValuesRef,\n    eagerValuesRef,\n    groupId,\n    layout,\n    panelDataArray: eagerValuesRef.current.panelDataArray,\n    setLayout,\n    panelGroupElement: panelGroupElementRef.current\n  });\n  useEffect(() => {\n    const {\n      panelDataArray\n    } = eagerValuesRef.current;\n\n    // If this panel has been configured to persist sizing information, save sizes to local storage.\n    if (autoSaveId) {\n      if (layout.length === 0 || layout.length !== panelDataArray.length) {\n        return;\n      }\n      let debouncedSave = debounceMap[autoSaveId];\n\n      // Limit the frequency of localStorage updates.\n      if (debouncedSave == null) {\n        debouncedSave = debounce(savePanelGroupState, LOCAL_STORAGE_DEBOUNCE_INTERVAL);\n        debounceMap[autoSaveId] = debouncedSave;\n      }\n\n      // Clone mutable data before passing to the debounced function,\n      // else we run the risk of saving an incorrect combination of mutable and immutable values to state.\n      const clonedPanelDataArray = [...panelDataArray];\n      const clonedPanelSizesBeforeCollapse = new Map(panelSizeBeforeCollapseRef.current);\n      debouncedSave(autoSaveId, clonedPanelDataArray, clonedPanelSizesBeforeCollapse, layout, storage);\n    }\n  }, [autoSaveId, layout, storage]);\n\n  // DEV warnings\n  useEffect(() => {\n    {\n      const {\n        panelDataArray\n      } = eagerValuesRef.current;\n      const {\n        didLogIdAndOrderWarning,\n        didLogPanelConstraintsWarning,\n        prevPanelIds\n      } = devWarningsRef.current;\n      if (!didLogIdAndOrderWarning) {\n        const panelIds = panelDataArray.map(({\n          id\n        }) => id);\n        devWarningsRef.current.prevPanelIds = panelIds;\n        const panelsHaveChanged = prevPanelIds.length > 0 && !areEqual(prevPanelIds, panelIds);\n        if (panelsHaveChanged) {\n          if (panelDataArray.find(({\n            idIsFromProps,\n            order\n          }) => !idIsFromProps || order == null)) {\n            devWarningsRef.current.didLogIdAndOrderWarning = true;\n            console.warn(`WARNING: Panel id and order props recommended when panels are dynamically rendered`);\n          }\n        }\n      }\n      if (!didLogPanelConstraintsWarning) {\n        const panelConstraints = panelDataArray.map(panelData => panelData.constraints);\n        for (let panelIndex = 0; panelIndex < panelConstraints.length; panelIndex++) {\n          const panelData = panelDataArray[panelIndex];\n          assert(panelData, `Panel data not found for index ${panelIndex}`);\n          const isValid = validatePanelConstraints({\n            panelConstraints,\n            panelId: panelData.id,\n            panelIndex\n          });\n          if (!isValid) {\n            devWarningsRef.current.didLogPanelConstraintsWarning = true;\n            break;\n          }\n        }\n      }\n    }\n  });\n\n  // External APIs are safe to memoize via committed values ref\n  const collapsePanel = useCallback(panelData => {\n    const {\n      onLayout\n    } = committedValuesRef.current;\n    const {\n      layout: prevLayout,\n      panelDataArray\n    } = eagerValuesRef.current;\n    if (panelData.constraints.collapsible) {\n      const panelConstraintsArray = panelDataArray.map(panelData => panelData.constraints);\n      const {\n        collapsedSize = 0,\n        panelSize,\n        pivotIndices\n      } = panelDataHelper(panelDataArray, panelData, prevLayout);\n      assert(panelSize != null, `Panel size not found for panel \"${panelData.id}\"`);\n      if (panelSize !== collapsedSize) {\n        // Store size before collapse;\n        // This is the size that gets restored if the expand() API is used.\n        panelSizeBeforeCollapseRef.current.set(panelData.id, panelSize);\n        const isLastPanel = findPanelDataIndex(panelDataArray, panelData) === panelDataArray.length - 1;\n        const delta = isLastPanel ? panelSize - collapsedSize : collapsedSize - panelSize;\n        const nextLayout = adjustLayoutByDelta({\n          delta,\n          initialLayout: prevLayout,\n          panelConstraints: panelConstraintsArray,\n          pivotIndices,\n          prevLayout,\n          trigger: \"imperative-api\"\n        });\n        if (!compareLayouts(prevLayout, nextLayout)) {\n          setLayout(nextLayout);\n          eagerValuesRef.current.layout = nextLayout;\n          if (onLayout) {\n            onLayout(nextLayout);\n          }\n          callPanelCallbacks(panelDataArray, nextLayout, panelIdToLastNotifiedSizeMapRef.current);\n        }\n      }\n    }\n  }, []);\n\n  // External APIs are safe to memoize via committed values ref\n  const expandPanel = useCallback(panelData => {\n    const {\n      onLayout\n    } = committedValuesRef.current;\n    const {\n      layout: prevLayout,\n      panelDataArray\n    } = eagerValuesRef.current;\n    if (panelData.constraints.collapsible) {\n      const panelConstraintsArray = panelDataArray.map(panelData => panelData.constraints);\n      const {\n        collapsedSize = 0,\n        panelSize,\n        minSize = 0,\n        pivotIndices\n      } = panelDataHelper(panelDataArray, panelData, prevLayout);\n      if (panelSize === collapsedSize) {\n        // Restore this panel to the size it was before it was collapsed, if possible.\n        const prevPanelSize = panelSizeBeforeCollapseRef.current.get(panelData.id);\n        const baseSize = prevPanelSize != null && prevPanelSize >= minSize ? prevPanelSize : minSize;\n        const isLastPanel = findPanelDataIndex(panelDataArray, panelData) === panelDataArray.length - 1;\n        const delta = isLastPanel ? panelSize - baseSize : baseSize - panelSize;\n        const nextLayout = adjustLayoutByDelta({\n          delta,\n          initialLayout: prevLayout,\n          panelConstraints: panelConstraintsArray,\n          pivotIndices,\n          prevLayout,\n          trigger: \"imperative-api\"\n        });\n        if (!compareLayouts(prevLayout, nextLayout)) {\n          setLayout(nextLayout);\n          eagerValuesRef.current.layout = nextLayout;\n          if (onLayout) {\n            onLayout(nextLayout);\n          }\n          callPanelCallbacks(panelDataArray, nextLayout, panelIdToLastNotifiedSizeMapRef.current);\n        }\n      }\n    }\n  }, []);\n\n  // External APIs are safe to memoize via committed values ref\n  const getPanelSize = useCallback(panelData => {\n    const {\n      layout,\n      panelDataArray\n    } = eagerValuesRef.current;\n    const {\n      panelSize\n    } = panelDataHelper(panelDataArray, panelData, layout);\n    assert(panelSize != null, `Panel size not found for panel \"${panelData.id}\"`);\n    return panelSize;\n  }, []);\n\n  // This API should never read from committedValuesRef\n  const getPanelStyle = useCallback((panelData, defaultSize) => {\n    const {\n      panelDataArray\n    } = eagerValuesRef.current;\n    const panelIndex = findPanelDataIndex(panelDataArray, panelData);\n    return computePanelFlexBoxStyle({\n      defaultSize,\n      dragState,\n      layout,\n      panelData: panelDataArray,\n      panelIndex\n    });\n  }, [dragState, layout]);\n\n  // External APIs are safe to memoize via committed values ref\n  const isPanelCollapsed = useCallback(panelData => {\n    const {\n      layout,\n      panelDataArray\n    } = eagerValuesRef.current;\n    const {\n      collapsedSize = 0,\n      collapsible,\n      panelSize\n    } = panelDataHelper(panelDataArray, panelData, layout);\n    return collapsible === true && panelSize === collapsedSize;\n  }, []);\n\n  // External APIs are safe to memoize via committed values ref\n  const isPanelExpanded = useCallback(panelData => {\n    const {\n      layout,\n      panelDataArray\n    } = eagerValuesRef.current;\n    const {\n      collapsedSize = 0,\n      collapsible,\n      panelSize\n    } = panelDataHelper(panelDataArray, panelData, layout);\n    assert(panelSize != null, `Panel size not found for panel \"${panelData.id}\"`);\n    return !collapsible || panelSize > collapsedSize;\n  }, []);\n  const registerPanel = useCallback(panelData => {\n    const {\n      panelDataArray\n    } = eagerValuesRef.current;\n    panelDataArray.push(panelData);\n    panelDataArray.sort((panelA, panelB) => {\n      const orderA = panelA.order;\n      const orderB = panelB.order;\n      if (orderA == null && orderB == null) {\n        return 0;\n      } else if (orderA == null) {\n        return -1;\n      } else if (orderB == null) {\n        return 1;\n      } else {\n        return orderA - orderB;\n      }\n    });\n    eagerValuesRef.current.panelDataArrayChanged = true;\n  }, []);\n  const registerResizeHandle = useCallback(dragHandleId => {\n    return function resizeHandler(event) {\n      event.preventDefault();\n      const panelGroupElement = panelGroupElementRef.current;\n      if (!panelGroupElement) {\n        return () => null;\n      }\n      const {\n        direction,\n        dragState,\n        id: groupId,\n        keyboardResizeBy,\n        onLayout\n      } = committedValuesRef.current;\n      const {\n        layout: prevLayout,\n        panelDataArray\n      } = eagerValuesRef.current;\n      const {\n        initialLayout\n      } = dragState !== null && dragState !== void 0 ? dragState : {};\n      const pivotIndices = determinePivotIndices(groupId, dragHandleId, panelGroupElement);\n      let delta = calculateDeltaPercentage(event, dragHandleId, direction, dragState, keyboardResizeBy, panelGroupElement);\n      if (delta === 0) {\n        return;\n      }\n\n      // Support RTL layouts\n      const isHorizontal = direction === \"horizontal\";\n      if (document.dir === \"rtl\" && isHorizontal) {\n        delta = -delta;\n      }\n      const panelConstraints = panelDataArray.map(panelData => panelData.constraints);\n      const nextLayout = adjustLayoutByDelta({\n        delta,\n        initialLayout: initialLayout !== null && initialLayout !== void 0 ? initialLayout : prevLayout,\n        panelConstraints,\n        pivotIndices,\n        prevLayout,\n        trigger: isKeyDown(event) ? \"keyboard\" : \"mouse-or-touch\"\n      });\n      const layoutChanged = !compareLayouts(prevLayout, nextLayout);\n\n      // Only update the cursor for layout changes triggered by touch/mouse events (not keyboard)\n      // Update the cursor even if the layout hasn't changed (we may need to show an invalid cursor state)\n      if (isMouseEvent(event) || isTouchEvent(event)) {\n        // Watch for multiple subsequent deltas; this might occur for tiny cursor movements.\n        // In this case, Panel sizes might not changeâ€“\n        // but updating cursor in this scenario would cause a flicker.\n        if (prevDeltaRef.current != delta) {\n          prevDeltaRef.current = delta;\n          if (!layoutChanged) {\n            // If the pointer has moved too far to resize the panel any further, note this so we can update the cursor.\n            // This mimics VS Code behavior.\n            if (isHorizontal) {\n              reportConstraintsViolation(dragHandleId, delta < 0 ? EXCEEDED_HORIZONTAL_MIN : EXCEEDED_HORIZONTAL_MAX);\n            } else {\n              reportConstraintsViolation(dragHandleId, delta < 0 ? EXCEEDED_VERTICAL_MIN : EXCEEDED_VERTICAL_MAX);\n            }\n          } else {\n            reportConstraintsViolation(dragHandleId, 0);\n          }\n        }\n      }\n      if (layoutChanged) {\n        setLayout(nextLayout);\n        eagerValuesRef.current.layout = nextLayout;\n        if (onLayout) {\n          onLayout(nextLayout);\n        }\n        callPanelCallbacks(panelDataArray, nextLayout, panelIdToLastNotifiedSizeMapRef.current);\n      }\n    };\n  }, []);\n\n  // External APIs are safe to memoize via committed values ref\n  const resizePanel = useCallback((panelData, unsafePanelSize) => {\n    const {\n      onLayout\n    } = committedValuesRef.current;\n    const {\n      layout: prevLayout,\n      panelDataArray\n    } = eagerValuesRef.current;\n    const panelConstraintsArray = panelDataArray.map(panelData => panelData.constraints);\n    const {\n      panelSize,\n      pivotIndices\n    } = panelDataHelper(panelDataArray, panelData, prevLayout);\n    assert(panelSize != null, `Panel size not found for panel \"${panelData.id}\"`);\n    const isLastPanel = findPanelDataIndex(panelDataArray, panelData) === panelDataArray.length - 1;\n    const delta = isLastPanel ? panelSize - unsafePanelSize : unsafePanelSize - panelSize;\n    const nextLayout = adjustLayoutByDelta({\n      delta,\n      initialLayout: prevLayout,\n      panelConstraints: panelConstraintsArray,\n      pivotIndices,\n      prevLayout,\n      trigger: \"imperative-api\"\n    });\n    if (!compareLayouts(prevLayout, nextLayout)) {\n      setLayout(nextLayout);\n      eagerValuesRef.current.layout = nextLayout;\n      if (onLayout) {\n        onLayout(nextLayout);\n      }\n      callPanelCallbacks(panelDataArray, nextLayout, panelIdToLastNotifiedSizeMapRef.current);\n    }\n  }, []);\n  const reevaluatePanelConstraints = useCallback((panelData, prevConstraints) => {\n    const {\n      layout,\n      panelDataArray\n    } = eagerValuesRef.current;\n    const {\n      collapsedSize: prevCollapsedSize = 0,\n      collapsible: prevCollapsible\n    } = prevConstraints;\n    const {\n      collapsedSize: nextCollapsedSize = 0,\n      collapsible: nextCollapsible,\n      maxSize: nextMaxSize = 100,\n      minSize: nextMinSize = 0\n    } = panelData.constraints;\n    const {\n      panelSize: prevPanelSize\n    } = panelDataHelper(panelDataArray, panelData, layout);\n    if (prevPanelSize == null) {\n      // It's possible that the panels in this group have changed since the last render\n      return;\n    }\n    if (prevCollapsible && nextCollapsible && prevPanelSize === prevCollapsedSize) {\n      if (prevCollapsedSize !== nextCollapsedSize) {\n        resizePanel(panelData, nextCollapsedSize);\n      }\n    } else if (prevPanelSize < nextMinSize) {\n      resizePanel(panelData, nextMinSize);\n    } else if (prevPanelSize > nextMaxSize) {\n      resizePanel(panelData, nextMaxSize);\n    }\n  }, [resizePanel]);\n  const startDragging = useCallback((dragHandleId, event) => {\n    const {\n      direction\n    } = committedValuesRef.current;\n    const {\n      layout\n    } = eagerValuesRef.current;\n    if (!panelGroupElementRef.current) {\n      return;\n    }\n    const handleElement = getResizeHandleElement(dragHandleId, panelGroupElementRef.current);\n    assert(handleElement, `Drag handle element not found for id \"${dragHandleId}\"`);\n    const initialCursorPosition = getResizeEventCursorPosition(direction, event);\n    setDragState({\n      dragHandleId,\n      dragHandleRect: handleElement.getBoundingClientRect(),\n      initialCursorPosition,\n      initialLayout: layout\n    });\n  }, []);\n  const stopDragging = useCallback(() => {\n    setDragState(null);\n  }, []);\n  const unregisterPanel = useCallback(panelData => {\n    const {\n      panelDataArray\n    } = eagerValuesRef.current;\n    const index = findPanelDataIndex(panelDataArray, panelData);\n    if (index >= 0) {\n      panelDataArray.splice(index, 1);\n\n      // TRICKY\n      // When a panel is removed from the group, we should delete the most recent prev-size entry for it.\n      // If we don't do this, then a conditionally rendered panel might not call onResize when it's re-mounted.\n      // Strict effects mode makes this tricky though because all panels will be registered, unregistered, then re-registered on mount.\n      delete panelIdToLastNotifiedSizeMapRef.current[panelData.id];\n      eagerValuesRef.current.panelDataArrayChanged = true;\n    }\n  }, []);\n  const context = useMemo(() => ({\n    collapsePanel,\n    direction,\n    dragState,\n    expandPanel,\n    getPanelSize,\n    getPanelStyle,\n    groupId,\n    isPanelCollapsed,\n    isPanelExpanded,\n    reevaluatePanelConstraints,\n    registerPanel,\n    registerResizeHandle,\n    resizePanel,\n    startDragging,\n    stopDragging,\n    unregisterPanel,\n    panelGroupElement: panelGroupElementRef.current\n  }), [collapsePanel, dragState, direction, expandPanel, getPanelSize, getPanelStyle, groupId, isPanelCollapsed, isPanelExpanded, reevaluatePanelConstraints, registerPanel, registerResizeHandle, resizePanel, startDragging, stopDragging, unregisterPanel]);\n  const style = {\n    display: \"flex\",\n    flexDirection: direction === \"horizontal\" ? \"row\" : \"column\",\n    height: \"100%\",\n    overflow: \"hidden\",\n    width: \"100%\"\n  };\n  return createElement(PanelGroupContext.Provider, {\n    value: context\n  }, createElement(Type, {\n    ...rest,\n    children,\n    className: classNameFromProps,\n    id: idFromProps,\n    ref: panelGroupElementRef,\n    style: {\n      ...style,\n      ...styleFromProps\n    },\n    // CSS selectors\n    \"data-panel-group\": \"\",\n    \"data-panel-group-direction\": direction,\n    \"data-panel-group-id\": groupId\n  }));\n}\nconst PanelGroup = forwardRef((props, ref) => createElement(PanelGroupWithForwardedRef, {\n  ...props,\n  forwardedRef: ref\n}));\nPanelGroupWithForwardedRef.displayName = \"PanelGroup\";\nPanelGroup.displayName = \"forwardRef(PanelGroup)\";\nfunction findPanelDataIndex(panelDataArray, panelData) {\n  return panelDataArray.findIndex(prevPanelData => prevPanelData === panelData || prevPanelData.id === panelData.id);\n}\nfunction panelDataHelper(panelDataArray, panelData, layout) {\n  const panelIndex = findPanelDataIndex(panelDataArray, panelData);\n  const isLastPanel = panelIndex === panelDataArray.length - 1;\n  const pivotIndices = isLastPanel ? [panelIndex - 1, panelIndex] : [panelIndex, panelIndex + 1];\n  const panelSize = layout[panelIndex];\n  return {\n    ...panelData.constraints,\n    panelSize,\n    pivotIndices\n  };\n}\n\n// https://www.w3.org/WAI/ARIA/apg/patterns/windowsplitter/\n\nfunction useWindowSplitterResizeHandlerBehavior({\n  disabled,\n  handleId,\n  resizeHandler,\n  panelGroupElement\n}) {\n  useEffect(() => {\n    if (disabled || resizeHandler == null || panelGroupElement == null) {\n      return;\n    }\n    const handleElement = getResizeHandleElement(handleId, panelGroupElement);\n    if (handleElement == null) {\n      return;\n    }\n    const onKeyDown = event => {\n      if (event.defaultPrevented) {\n        return;\n      }\n      switch (event.key) {\n        case \"ArrowDown\":\n        case \"ArrowLeft\":\n        case \"ArrowRight\":\n        case \"ArrowUp\":\n        case \"End\":\n        case \"Home\":\n          {\n            event.preventDefault();\n            resizeHandler(event);\n            break;\n          }\n        case \"F6\":\n          {\n            event.preventDefault();\n            const groupId = handleElement.getAttribute(\"data-panel-group-id\");\n            assert(groupId, `No group element found for id \"${groupId}\"`);\n            const handles = getResizeHandleElementsForGroup(groupId, panelGroupElement);\n            const index = getResizeHandleElementIndex(groupId, handleId, panelGroupElement);\n            assert(index !== null, `No resize element found for id \"${handleId}\"`);\n            const nextIndex = event.shiftKey ? index > 0 ? index - 1 : handles.length - 1 : index + 1 < handles.length ? index + 1 : 0;\n            const nextHandle = handles[nextIndex];\n            nextHandle.focus();\n            break;\n          }\n      }\n    };\n    handleElement.addEventListener(\"keydown\", onKeyDown);\n    return () => {\n      handleElement.removeEventListener(\"keydown\", onKeyDown);\n    };\n  }, [panelGroupElement, disabled, handleId, resizeHandler]);\n}\n\nfunction PanelResizeHandle({\n  children = null,\n  className: classNameFromProps = \"\",\n  disabled = false,\n  hitAreaMargins,\n  id: idFromProps,\n  onDragging,\n  style: styleFromProps = {},\n  tabIndex = 0,\n  tagName: Type = \"div\",\n  ...rest\n}) {\n  const elementRef = useRef(null);\n\n  // Use a ref to guard against users passing inline props\n  const callbacksRef = useRef({\n    onDragging\n  });\n  useEffect(() => {\n    callbacksRef.current.onDragging = onDragging;\n  });\n  const panelGroupContext = useContext(PanelGroupContext);\n  if (panelGroupContext === null) {\n    throw Error(`PanelResizeHandle components must be rendered within a PanelGroup container`);\n  }\n  const {\n    direction,\n    groupId,\n    registerResizeHandle: registerResizeHandleWithParentGroup,\n    startDragging,\n    stopDragging,\n    panelGroupElement\n  } = panelGroupContext;\n  const resizeHandleId = useUniqueId(idFromProps);\n  const [state, setState] = useState(\"inactive\");\n  const [isFocused, setIsFocused] = useState(false);\n  const [resizeHandler, setResizeHandler] = useState(null);\n  const committedValuesRef = useRef({\n    state\n  });\n  useEffect(() => {\n    if (disabled) {\n      setResizeHandler(null);\n    } else {\n      const resizeHandler = registerResizeHandleWithParentGroup(resizeHandleId);\n      setResizeHandler(() => resizeHandler);\n    }\n  }, [disabled, resizeHandleId, registerResizeHandleWithParentGroup]);\n  useEffect(() => {\n    var _hitAreaMargins$coars, _hitAreaMargins$fine;\n    if (disabled || resizeHandler == null) {\n      return;\n    }\n    const element = elementRef.current;\n    assert(element, \"Element ref not attached\");\n    const setResizeHandlerState = (action, isActive, event) => {\n      if (isActive) {\n        switch (action) {\n          case \"down\":\n            {\n              setState(\"drag\");\n              startDragging(resizeHandleId, event);\n              const {\n                onDragging\n              } = callbacksRef.current;\n              if (onDragging) {\n                onDragging(true);\n              }\n              break;\n            }\n          case \"move\":\n            {\n              const {\n                state\n              } = committedValuesRef.current;\n              if (state !== \"drag\") {\n                setState(\"hover\");\n              }\n              resizeHandler(event);\n              break;\n            }\n          case \"up\":\n            {\n              setState(\"hover\");\n              stopDragging();\n              const {\n                onDragging\n              } = callbacksRef.current;\n              if (onDragging) {\n                onDragging(false);\n              }\n              break;\n            }\n        }\n      } else {\n        setState(\"inactive\");\n      }\n    };\n    return registerResizeHandle(resizeHandleId, element, direction, {\n      // Coarse inputs (e.g. finger/touch)\n      coarse: (_hitAreaMargins$coars = hitAreaMargins === null || hitAreaMargins === void 0 ? void 0 : hitAreaMargins.coarse) !== null && _hitAreaMargins$coars !== void 0 ? _hitAreaMargins$coars : 15,\n      // Fine inputs (e.g. mouse)\n      fine: (_hitAreaMargins$fine = hitAreaMargins === null || hitAreaMargins === void 0 ? void 0 : hitAreaMargins.fine) !== null && _hitAreaMargins$fine !== void 0 ? _hitAreaMargins$fine : 5\n    }, setResizeHandlerState);\n  }, [direction, disabled, hitAreaMargins, registerResizeHandleWithParentGroup, resizeHandleId, resizeHandler, startDragging, stopDragging]);\n  useWindowSplitterResizeHandlerBehavior({\n    disabled,\n    handleId: resizeHandleId,\n    resizeHandler,\n    panelGroupElement\n  });\n  const style = {\n    touchAction: \"none\",\n    userSelect: \"none\"\n  };\n  return createElement(Type, {\n    ...rest,\n    children,\n    className: classNameFromProps,\n    id: idFromProps,\n    onBlur: () => setIsFocused(false),\n    onFocus: () => setIsFocused(true),\n    ref: elementRef,\n    role: \"separator\",\n    style: {\n      ...style,\n      ...styleFromProps\n    },\n    tabIndex,\n    // CSS selectors\n    \"data-panel-group-direction\": direction,\n    \"data-panel-group-id\": groupId,\n    \"data-resize-handle\": \"\",\n    \"data-resize-handle-active\": state === \"drag\" ? \"pointer\" : isFocused ? \"keyboard\" : undefined,\n    \"data-resize-handle-state\": state,\n    \"data-panel-resize-handle-enabled\": !disabled,\n    \"data-panel-resize-handle-id\": resizeHandleId\n  });\n}\nPanelResizeHandle.displayName = \"PanelResizeHandle\";\n\nfunction getPanelElement(id, scope = document) {\n  const element = scope.querySelector(`[data-panel-id=\"${id}\"]`);\n  if (element) {\n    return element;\n  }\n  return null;\n}\n\nfunction getPanelElementsForGroup(groupId, scope = document) {\n  return Array.from(scope.querySelectorAll(`[data-panel][data-panel-group-id=\"${groupId}\"]`));\n}\n\nfunction getIntersectingRectangle(rectOne, rectTwo, strict) {\n  if (!intersects(rectOne, rectTwo, strict)) {\n    return {\n      x: 0,\n      y: 0,\n      width: 0,\n      height: 0\n    };\n  }\n  return {\n    x: Math.max(rectOne.x, rectTwo.x),\n    y: Math.max(rectOne.y, rectTwo.y),\n    width: Math.min(rectOne.x + rectOne.width, rectTwo.x + rectTwo.width) - Math.max(rectOne.x, rectTwo.x),\n    height: Math.min(rectOne.y + rectOne.height, rectTwo.y + rectTwo.height) - Math.max(rectOne.y, rectTwo.y)\n  };\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtcmVzaXphYmxlLXBhbmVscy9kaXN0L3JlYWN0LXJlc2l6YWJsZS1wYW5lbHMuZGV2ZWxvcG1lbnQubm9kZS5lc20uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQStCOztBQUUvQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsRUFBRSxrQ0FBSzs7QUFFVCwyREFBMkQsUUFBUTtBQUNuRSxjQUFjLGtDQUFLOztBQUVuQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixVQUFVLE1BQU0sWUFBWTtBQUMxRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGFBQWE7QUFDeEIsV0FBVyxhQUFhO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFlBQVksYUFBYTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxZQUFZLGFBQWE7QUFDekI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFlBQVksZUFBZTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsWUFBWSxhQUFhO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQSxZQUFZLGFBQWE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCOztBQUVBLFlBQVksYUFBYTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxHQUFH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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThELFFBQVE7QUFDdEU7QUFDQTtBQUNBLHNFQUFzRSxTQUFTO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBLHlEQUF5RCxHQUFHO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnRkFBZ0YsUUFBUTtBQUN4Rjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFOFEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jb2RlemFyZC8uL25vZGVfbW9kdWxlcy9yZWFjdC1yZXNpemFibGUtcGFuZWxzL2Rpc3QvcmVhY3QtcmVzaXphYmxlLXBhbmVscy5kZXZlbG9wbWVudC5ub2RlLmVzbS5qcz8wMWNmIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcblxuLy8gVGhpcyBtb2R1bGUgZXhpc3RzIHRvIHdvcmsgYXJvdW5kIFdlYnBhY2sgaXNzdWUgaHR0cHM6Ly9naXRodWIuY29tL3dlYnBhY2svd2VicGFjay9pc3N1ZXMvMTQ4MTRcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlc3RyaWN0ZWQtaW1wb3J0c1xuXG5jb25zdCB7XG4gIGNyZWF0ZUVsZW1lbnQsXG4gIGNyZWF0ZUNvbnRleHQsXG4gIGNyZWF0ZVJlZixcbiAgZm9yd2FyZFJlZixcbiAgdXNlQ2FsbGJhY2ssXG4gIHVzZUNvbnRleHQsXG4gIHVzZUVmZmVjdCxcbiAgdXNlSW1wZXJhdGl2ZUhhbmRsZSxcbiAgdXNlTGF5b3V0RWZmZWN0LFxuICB1c2VNZW1vLFxuICB1c2VSZWYsXG4gIHVzZVN0YXRlXG59ID0gUmVhY3Q7XG5cbi8vIGB0b1N0cmluZygpYCBwcmV2ZW50cyBidW5kbGVycyBmcm9tIHRyeWluZyB0byBgaW1wb3J0IHsgdXNlSWQgfSBmcm9tICdyZWFjdCdgXG5jb25zdCB1c2VJZCA9IFJlYWN0W1widXNlSWRcIi50b1N0cmluZygpXTtcblxuY29uc3QgUGFuZWxHcm91cENvbnRleHQgPSBjcmVhdGVDb250ZXh0KG51bGwpO1xuUGFuZWxHcm91cENvbnRleHQuZGlzcGxheU5hbWUgPSBcIlBhbmVsR3JvdXBDb250ZXh0XCI7XG5cbmNvbnN0IHdyYXBwZWRVc2VJZCA9IHR5cGVvZiB1c2VJZCA9PT0gXCJmdW5jdGlvblwiID8gdXNlSWQgOiAoKSA9PiBudWxsO1xubGV0IGNvdW50ZXIgPSAwO1xuZnVuY3Rpb24gdXNlVW5pcXVlSWQoaWRGcm9tUGFyYW1zID0gbnVsbCkge1xuICBjb25zdCBpZEZyb21Vc2VJZCA9IHdyYXBwZWRVc2VJZCgpO1xuICBjb25zdCBpZFJlZiA9IHVzZVJlZihpZEZyb21QYXJhbXMgfHwgaWRGcm9tVXNlSWQgfHwgbnVsbCk7XG4gIGlmIChpZFJlZi5jdXJyZW50ID09PSBudWxsKSB7XG4gICAgaWRSZWYuY3VycmVudCA9IFwiXCIgKyBjb3VudGVyKys7XG4gIH1cbiAgcmV0dXJuIGlkRnJvbVBhcmFtcyAhPT0gbnVsbCAmJiBpZEZyb21QYXJhbXMgIT09IHZvaWQgMCA/IGlkRnJvbVBhcmFtcyA6IGlkUmVmLmN1cnJlbnQ7XG59XG5cbmZ1bmN0aW9uIFBhbmVsV2l0aEZvcndhcmRlZFJlZih7XG4gIGNoaWxkcmVuLFxuICBjbGFzc05hbWU6IGNsYXNzTmFtZUZyb21Qcm9wcyA9IFwiXCIsXG4gIGNvbGxhcHNlZFNpemUsXG4gIGNvbGxhcHNpYmxlLFxuICBkZWZhdWx0U2l6ZSxcbiAgZm9yd2FyZGVkUmVmLFxuICBpZDogaWRGcm9tUHJvcHMsXG4gIG1heFNpemUsXG4gIG1pblNpemUsXG4gIG9uQ29sbGFwc2UsXG4gIG9uRXhwYW5kLFxuICBvblJlc2l6ZSxcbiAgb3JkZXIsXG4gIHN0eWxlOiBzdHlsZUZyb21Qcm9wcyxcbiAgdGFnTmFtZTogVHlwZSA9IFwiZGl2XCIsXG4gIC4uLnJlc3Rcbn0pIHtcbiAgY29uc3QgY29udGV4dCA9IHVzZUNvbnRleHQoUGFuZWxHcm91cENvbnRleHQpO1xuICBpZiAoY29udGV4dCA9PT0gbnVsbCkge1xuICAgIHRocm93IEVycm9yKGBQYW5lbCBjb21wb25lbnRzIG11c3QgYmUgcmVuZGVyZWQgd2l0aGluIGEgUGFuZWxHcm91cCBjb250YWluZXJgKTtcbiAgfVxuICBjb25zdCB7XG4gICAgY29sbGFwc2VQYW5lbCxcbiAgICBleHBhbmRQYW5lbCxcbiAgICBnZXRQYW5lbFNpemUsXG4gICAgZ2V0UGFuZWxTdHlsZSxcbiAgICBncm91cElkLFxuICAgIGlzUGFuZWxDb2xsYXBzZWQsXG4gICAgcmVldmFsdWF0ZVBhbmVsQ29uc3RyYWludHMsXG4gICAgcmVnaXN0ZXJQYW5lbCxcbiAgICByZXNpemVQYW5lbCxcbiAgICB1bnJlZ2lzdGVyUGFuZWxcbiAgfSA9IGNvbnRleHQ7XG4gIGNvbnN0IHBhbmVsSWQgPSB1c2VVbmlxdWVJZChpZEZyb21Qcm9wcyk7XG4gIGNvbnN0IHBhbmVsRGF0YVJlZiA9IHVzZVJlZih7XG4gICAgY2FsbGJhY2tzOiB7XG4gICAgICBvbkNvbGxhcHNlLFxuICAgICAgb25FeHBhbmQsXG4gICAgICBvblJlc2l6ZVxuICAgIH0sXG4gICAgY29uc3RyYWludHM6IHtcbiAgICAgIGNvbGxhcHNlZFNpemUsXG4gICAgICBjb2xsYXBzaWJsZSxcbiAgICAgIGRlZmF1bHRTaXplLFxuICAgICAgbWF4U2l6ZSxcbiAgICAgIG1pblNpemVcbiAgICB9LFxuICAgIGlkOiBwYW5lbElkLFxuICAgIGlkSXNGcm9tUHJvcHM6IGlkRnJvbVByb3BzICE9PSB1bmRlZmluZWQsXG4gICAgb3JkZXJcbiAgfSk7XG4gIGNvbnN0IGRldldhcm5pbmdzUmVmID0gdXNlUmVmKHtcbiAgICBkaWRMb2dNaXNzaW5nRGVmYXVsdFNpemVXYXJuaW5nOiBmYWxzZVxuICB9KTtcblxuICAvLyBOb3JtYWxseSB3ZSB3b3VsZG4ndCBsb2cgYSB3YXJuaW5nIGR1cmluZyByZW5kZXIsXG4gIC8vIGJ1dCBlZmZlY3RzIGRvbid0IHJ1biBvbiB0aGUgc2VydmVyLCBzbyB3ZSBjYW4ndCBkbyBpdCB0aGVyZVxuICB7XG4gICAgaWYgKCFkZXZXYXJuaW5nc1JlZi5jdXJyZW50LmRpZExvZ01pc3NpbmdEZWZhdWx0U2l6ZVdhcm5pbmcpIHtcbiAgICAgIGlmIChkZWZhdWx0U2l6ZSA9PSBudWxsKSB7XG4gICAgICAgIGRldldhcm5pbmdzUmVmLmN1cnJlbnQuZGlkTG9nTWlzc2luZ0RlZmF1bHRTaXplV2FybmluZyA9IHRydWU7XG4gICAgICAgIGNvbnNvbGUud2FybihgV0FSTklORzogUGFuZWwgZGVmYXVsdFNpemUgcHJvcCByZWNvbW1lbmRlZCB0byBhdm9pZCBsYXlvdXQgc2hpZnQgYWZ0ZXIgc2VydmVyIHJlbmRlcmluZ2ApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICB1c2VJbXBlcmF0aXZlSGFuZGxlKGZvcndhcmRlZFJlZiwgKCkgPT4gKHtcbiAgICBjb2xsYXBzZTogKCkgPT4ge1xuICAgICAgY29sbGFwc2VQYW5lbChwYW5lbERhdGFSZWYuY3VycmVudCk7XG4gICAgfSxcbiAgICBleHBhbmQ6ICgpID0+IHtcbiAgICAgIGV4cGFuZFBhbmVsKHBhbmVsRGF0YVJlZi5jdXJyZW50KTtcbiAgICB9LFxuICAgIGdldElkKCkge1xuICAgICAgcmV0dXJuIHBhbmVsSWQ7XG4gICAgfSxcbiAgICBnZXRTaXplKCkge1xuICAgICAgcmV0dXJuIGdldFBhbmVsU2l6ZShwYW5lbERhdGFSZWYuY3VycmVudCk7XG4gICAgfSxcbiAgICBpc0NvbGxhcHNlZCgpIHtcbiAgICAgIHJldHVybiBpc1BhbmVsQ29sbGFwc2VkKHBhbmVsRGF0YVJlZi5jdXJyZW50KTtcbiAgICB9LFxuICAgIGlzRXhwYW5kZWQoKSB7XG4gICAgICByZXR1cm4gIWlzUGFuZWxDb2xsYXBzZWQocGFuZWxEYXRhUmVmLmN1cnJlbnQpO1xuICAgIH0sXG4gICAgcmVzaXplOiBzaXplID0+IHtcbiAgICAgIHJlc2l6ZVBhbmVsKHBhbmVsRGF0YVJlZi5jdXJyZW50LCBzaXplKTtcbiAgICB9XG4gIH0pLCBbY29sbGFwc2VQYW5lbCwgZXhwYW5kUGFuZWwsIGdldFBhbmVsU2l6ZSwgaXNQYW5lbENvbGxhcHNlZCwgcGFuZWxJZCwgcmVzaXplUGFuZWxdKTtcbiAgY29uc3Qgc3R5bGUgPSBnZXRQYW5lbFN0eWxlKHBhbmVsRGF0YVJlZi5jdXJyZW50LCBkZWZhdWx0U2l6ZSk7XG4gIHJldHVybiBjcmVhdGVFbGVtZW50KFR5cGUsIHtcbiAgICAuLi5yZXN0LFxuICAgIGNoaWxkcmVuLFxuICAgIGNsYXNzTmFtZTogY2xhc3NOYW1lRnJvbVByb3BzLFxuICAgIGlkOiBpZEZyb21Qcm9wcyxcbiAgICBzdHlsZToge1xuICAgICAgLi4uc3R5bGUsXG4gICAgICAuLi5zdHlsZUZyb21Qcm9wc1xuICAgIH0sXG4gICAgLy8gQ1NTIHNlbGVjdG9yc1xuICAgIFwiZGF0YS1wYW5lbFwiOiBcIlwiLFxuICAgIFwiZGF0YS1wYW5lbC1jb2xsYXBzaWJsZVwiOiBjb2xsYXBzaWJsZSB8fCB1bmRlZmluZWQsXG4gICAgXCJkYXRhLXBhbmVsLWdyb3VwLWlkXCI6IGdyb3VwSWQsXG4gICAgXCJkYXRhLXBhbmVsLWlkXCI6IHBhbmVsSWQsXG4gICAgXCJkYXRhLXBhbmVsLXNpemVcIjogcGFyc2VGbG9hdChcIlwiICsgc3R5bGUuZmxleEdyb3cpLnRvRml4ZWQoMSlcbiAgfSk7XG59XG5jb25zdCBQYW5lbCA9IGZvcndhcmRSZWYoKHByb3BzLCByZWYpID0+IGNyZWF0ZUVsZW1lbnQoUGFuZWxXaXRoRm9yd2FyZGVkUmVmLCB7XG4gIC4uLnByb3BzLFxuICBmb3J3YXJkZWRSZWY6IHJlZlxufSkpO1xuUGFuZWxXaXRoRm9yd2FyZGVkUmVmLmRpc3BsYXlOYW1lID0gXCJQYW5lbFwiO1xuUGFuZWwuZGlzcGxheU5hbWUgPSBcImZvcndhcmRSZWYoUGFuZWwpXCI7XG5cbmxldCBjdXJyZW50Q3Vyc29yU3R5bGUgPSBudWxsO1xubGV0IHN0eWxlRWxlbWVudCA9IG51bGw7XG5mdW5jdGlvbiBnZXRDdXJzb3JTdHlsZShzdGF0ZSwgY29uc3RyYWludEZsYWdzKSB7XG4gIGlmIChjb25zdHJhaW50RmxhZ3MpIHtcbiAgICBjb25zdCBob3Jpem9udGFsTWluID0gKGNvbnN0cmFpbnRGbGFncyAmIEVYQ0VFREVEX0hPUklaT05UQUxfTUlOKSAhPT0gMDtcbiAgICBjb25zdCBob3Jpem9udGFsTWF4ID0gKGNvbnN0cmFpbnRGbGFncyAmIEVYQ0VFREVEX0hPUklaT05UQUxfTUFYKSAhPT0gMDtcbiAgICBjb25zdCB2ZXJ0aWNhbE1pbiA9IChjb25zdHJhaW50RmxhZ3MgJiBFWENFRURFRF9WRVJUSUNBTF9NSU4pICE9PSAwO1xuICAgIGNvbnN0IHZlcnRpY2FsTWF4ID0gKGNvbnN0cmFpbnRGbGFncyAmIEVYQ0VFREVEX1ZFUlRJQ0FMX01BWCkgIT09IDA7XG4gICAgaWYgKGhvcml6b250YWxNaW4pIHtcbiAgICAgIGlmICh2ZXJ0aWNhbE1pbikge1xuICAgICAgICByZXR1cm4gXCJzZS1yZXNpemVcIjtcbiAgICAgIH0gZWxzZSBpZiAodmVydGljYWxNYXgpIHtcbiAgICAgICAgcmV0dXJuIFwibmUtcmVzaXplXCI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gXCJlLXJlc2l6ZVwiO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaG9yaXpvbnRhbE1heCkge1xuICAgICAgaWYgKHZlcnRpY2FsTWluKSB7XG4gICAgICAgIHJldHVybiBcInN3LXJlc2l6ZVwiO1xuICAgICAgfSBlbHNlIGlmICh2ZXJ0aWNhbE1heCkge1xuICAgICAgICByZXR1cm4gXCJudy1yZXNpemVcIjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBcInctcmVzaXplXCI7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh2ZXJ0aWNhbE1pbikge1xuICAgICAgcmV0dXJuIFwicy1yZXNpemVcIjtcbiAgICB9IGVsc2UgaWYgKHZlcnRpY2FsTWF4KSB7XG4gICAgICByZXR1cm4gXCJuLXJlc2l6ZVwiO1xuICAgIH1cbiAgfVxuICBzd2l0Y2ggKHN0YXRlKSB7XG4gICAgY2FzZSBcImhvcml6b250YWxcIjpcbiAgICAgIHJldHVybiBcImV3LXJlc2l6ZVwiO1xuICAgIGNhc2UgXCJpbnRlcnNlY3Rpb25cIjpcbiAgICAgIHJldHVybiBcIm1vdmVcIjtcbiAgICBjYXNlIFwidmVydGljYWxcIjpcbiAgICAgIHJldHVybiBcIm5zLXJlc2l6ZVwiO1xuICB9XG59XG5mdW5jdGlvbiByZXNldEdsb2JhbEN1cnNvclN0eWxlKCkge1xuICBpZiAoc3R5bGVFbGVtZW50ICE9PSBudWxsKSB7XG4gICAgZG9jdW1lbnQuaGVhZC5yZW1vdmVDaGlsZChzdHlsZUVsZW1lbnQpO1xuICAgIGN1cnJlbnRDdXJzb3JTdHlsZSA9IG51bGw7XG4gICAgc3R5bGVFbGVtZW50ID0gbnVsbDtcbiAgfVxufVxuZnVuY3Rpb24gc2V0R2xvYmFsQ3Vyc29yU3R5bGUoc3RhdGUsIGNvbnN0cmFpbnRGbGFncykge1xuICBjb25zdCBzdHlsZSA9IGdldEN1cnNvclN0eWxlKHN0YXRlLCBjb25zdHJhaW50RmxhZ3MpO1xuICBpZiAoY3VycmVudEN1cnNvclN0eWxlID09PSBzdHlsZSkge1xuICAgIHJldHVybjtcbiAgfVxuICBjdXJyZW50Q3Vyc29yU3R5bGUgPSBzdHlsZTtcbiAgaWYgKHN0eWxlRWxlbWVudCA9PT0gbnVsbCkge1xuICAgIHN0eWxlRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzdHlsZVwiKTtcbiAgICBkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKHN0eWxlRWxlbWVudCk7XG4gIH1cbiAgc3R5bGVFbGVtZW50LmlubmVySFRNTCA9IGAqe2N1cnNvcjogJHtzdHlsZX0haW1wb3J0YW50O31gO1xufVxuXG5mdW5jdGlvbiBpc0tleURvd24oZXZlbnQpIHtcbiAgcmV0dXJuIGV2ZW50LnR5cGUgPT09IFwia2V5ZG93blwiO1xufVxuZnVuY3Rpb24gaXNNb3VzZUV2ZW50KGV2ZW50KSB7XG4gIHJldHVybiBldmVudC50eXBlLnN0YXJ0c1dpdGgoXCJtb3VzZVwiKTtcbn1cbmZ1bmN0aW9uIGlzVG91Y2hFdmVudChldmVudCkge1xuICByZXR1cm4gZXZlbnQudHlwZS5zdGFydHNXaXRoKFwidG91Y2hcIik7XG59XG5cbmZ1bmN0aW9uIGdldFJlc2l6ZUV2ZW50Q29vcmRpbmF0ZXMoZXZlbnQpIHtcbiAgaWYgKGlzTW91c2VFdmVudChldmVudCkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgeDogZXZlbnQuY2xpZW50WCxcbiAgICAgIHk6IGV2ZW50LmNsaWVudFlcbiAgICB9O1xuICB9IGVsc2UgaWYgKGlzVG91Y2hFdmVudChldmVudCkpIHtcbiAgICBjb25zdCB0b3VjaCA9IGV2ZW50LnRvdWNoZXNbMF07XG4gICAgaWYgKHRvdWNoICYmIHRvdWNoLmNsaWVudFggJiYgdG91Y2guY2xpZW50WSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDogdG91Y2guY2xpZW50WCxcbiAgICAgICAgeTogdG91Y2guY2xpZW50WVxuICAgICAgfTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB4OiBJbmZpbml0eSxcbiAgICB5OiBJbmZpbml0eVxuICB9O1xufVxuXG5mdW5jdGlvbiBnZXRJbnB1dFR5cGUoKSB7XG4gIGlmICh0eXBlb2YgbWF0Y2hNZWRpYSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgcmV0dXJuIG1hdGNoTWVkaWEoXCIocG9pbnRlcjpjb2Fyc2UpXCIpLm1hdGNoZXMgPyBcImNvYXJzZVwiIDogXCJmaW5lXCI7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW50ZXJzZWN0cyhyZWN0T25lLCByZWN0VHdvLCBzdHJpY3QpIHtcbiAgaWYgKHN0cmljdCkge1xuICAgIHJldHVybiByZWN0T25lLnggPCByZWN0VHdvLnggKyByZWN0VHdvLndpZHRoICYmIHJlY3RPbmUueCArIHJlY3RPbmUud2lkdGggPiByZWN0VHdvLnggJiYgcmVjdE9uZS55IDwgcmVjdFR3by55ICsgcmVjdFR3by5oZWlnaHQgJiYgcmVjdE9uZS55ICsgcmVjdE9uZS5oZWlnaHQgPiByZWN0VHdvLnk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHJlY3RPbmUueCA8PSByZWN0VHdvLnggKyByZWN0VHdvLndpZHRoICYmIHJlY3RPbmUueCArIHJlY3RPbmUud2lkdGggPj0gcmVjdFR3by54ICYmIHJlY3RPbmUueSA8PSByZWN0VHdvLnkgKyByZWN0VHdvLmhlaWdodCAmJiByZWN0T25lLnkgKyByZWN0T25lLmhlaWdodCA+PSByZWN0VHdvLnk7XG4gIH1cbn1cblxuLy8gRm9ya2VkIGZyb20gTlBNIHN0YWNraW5nLW9yZGVyQDIuMC4wXG5cbi8qKlxuICogRGV0ZXJtaW5lIHdoaWNoIG9mIHR3byBub2RlcyBhcHBlYXJzIGluIGZyb250IG9mIHRoZSBvdGhlciDigJRcbiAqIGlmIGBhYCBpcyBpbiBmcm9udCwgcmV0dXJucyAxLCBvdGhlcndpc2UgcmV0dXJucyAtMVxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gYVxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gYlxuICovXG5mdW5jdGlvbiBjb21wYXJlKGEsIGIpIHtcbiAgaWYgKGEgPT09IGIpIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBjb21wYXJlIG5vZGUgd2l0aCBpdHNlbGZcIik7XG4gIGNvbnN0IGFuY2VzdG9ycyA9IHtcbiAgICBhOiBnZXRfYW5jZXN0b3JzKGEpLFxuICAgIGI6IGdldF9hbmNlc3RvcnMoYilcbiAgfTtcbiAgbGV0IGNvbW1vbl9hbmNlc3RvcjtcblxuICAvLyByZW1vdmUgc2hhcmVkIGFuY2VzdG9yc1xuICB3aGlsZSAoYW5jZXN0b3JzLmEuYXQoLTEpID09PSBhbmNlc3RvcnMuYi5hdCgtMSkpIHtcbiAgICBhID0gYW5jZXN0b3JzLmEucG9wKCk7XG4gICAgYiA9IGFuY2VzdG9ycy5iLnBvcCgpO1xuICAgIGNvbW1vbl9hbmNlc3RvciA9IGE7XG4gIH1cbiAgYXNzZXJ0KGNvbW1vbl9hbmNlc3RvciwgXCJTdGFja2luZyBvcmRlciBjYW4gb25seSBiZSBjYWxjdWxhdGVkIGZvciBlbGVtZW50cyB3aXRoIGEgY29tbW9uIGFuY2VzdG9yXCIpO1xuICBjb25zdCB6X2luZGV4ZXMgPSB7XG4gICAgYTogZ2V0X3pfaW5kZXgoZmluZF9zdGFja2luZ19jb250ZXh0KGFuY2VzdG9ycy5hKSksXG4gICAgYjogZ2V0X3pfaW5kZXgoZmluZF9zdGFja2luZ19jb250ZXh0KGFuY2VzdG9ycy5iKSlcbiAgfTtcbiAgaWYgKHpfaW5kZXhlcy5hID09PSB6X2luZGV4ZXMuYikge1xuICAgIGNvbnN0IGNoaWxkcmVuID0gY29tbW9uX2FuY2VzdG9yLmNoaWxkTm9kZXM7XG4gICAgY29uc3QgZnVydGhlc3RfYW5jZXN0b3JzID0ge1xuICAgICAgYTogYW5jZXN0b3JzLmEuYXQoLTEpLFxuICAgICAgYjogYW5jZXN0b3JzLmIuYXQoLTEpXG4gICAgfTtcbiAgICBsZXQgaSA9IGNoaWxkcmVuLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICBjb25zdCBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuICAgICAgaWYgKGNoaWxkID09PSBmdXJ0aGVzdF9hbmNlc3RvcnMuYSkgcmV0dXJuIDE7XG4gICAgICBpZiAoY2hpbGQgPT09IGZ1cnRoZXN0X2FuY2VzdG9ycy5iKSByZXR1cm4gLTE7XG4gICAgfVxuICB9XG4gIHJldHVybiBNYXRoLnNpZ24oel9pbmRleGVzLmEgLSB6X2luZGV4ZXMuYik7XG59XG5jb25zdCBwcm9wcyA9IC9cXGIoPzpwb3NpdGlvbnx6SW5kZXh8b3BhY2l0eXx0cmFuc2Zvcm18d2Via2l0VHJhbnNmb3JtfG1peEJsZW5kTW9kZXxmaWx0ZXJ8d2Via2l0RmlsdGVyfGlzb2xhdGlvbilcXGIvO1xuXG4vKiogQHBhcmFtIHtIVE1MRWxlbWVudH0gbm9kZSAqL1xuZnVuY3Rpb24gaXNfZmxleF9pdGVtKG5vZGUpIHtcbiAgY29uc3QgZGlzcGxheSA9IGdldENvbXB1dGVkU3R5bGUoZ2V0X3BhcmVudChub2RlKSkuZGlzcGxheTtcbiAgcmV0dXJuIGRpc3BsYXkgPT09IFwiZmxleFwiIHx8IGRpc3BsYXkgPT09IFwiaW5saW5lLWZsZXhcIjtcbn1cblxuLyoqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IG5vZGUgKi9cbmZ1bmN0aW9uIGNyZWF0ZXNfc3RhY2tpbmdfY29udGV4dChub2RlKSB7XG4gIGNvbnN0IHN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZShub2RlKTtcblxuICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9DU1MvQ1NTX1Bvc2l0aW9uaW5nL1VuZGVyc3RhbmRpbmdfel9pbmRleC9UaGVfc3RhY2tpbmdfY29udGV4dFxuICBpZiAoc3R5bGUucG9zaXRpb24gPT09IFwiZml4ZWRcIikgcmV0dXJuIHRydWU7XG4gIC8vIEZvcmtlZCB0byBmaXggdXBzdHJlYW0gYnVnIGh0dHBzOi8vZ2l0aHViLmNvbS9SaWNoLUhhcnJpcy9zdGFja2luZy1vcmRlci9pc3N1ZXMvM1xuICAvLyBpZiAoXG4gIC8vICAgKHN0eWxlLnpJbmRleCAhPT0gXCJhdXRvXCIgJiYgc3R5bGUucG9zaXRpb24gIT09IFwic3RhdGljXCIpIHx8XG4gIC8vICAgaXNfZmxleF9pdGVtKG5vZGUpXG4gIC8vIClcbiAgaWYgKHN0eWxlLnpJbmRleCAhPT0gXCJhdXRvXCIgJiYgKHN0eWxlLnBvc2l0aW9uICE9PSBcInN0YXRpY1wiIHx8IGlzX2ZsZXhfaXRlbShub2RlKSkpIHJldHVybiB0cnVlO1xuICBpZiAoK3N0eWxlLm9wYWNpdHkgPCAxKSByZXR1cm4gdHJ1ZTtcbiAgaWYgKFwidHJhbnNmb3JtXCIgaW4gc3R5bGUgJiYgc3R5bGUudHJhbnNmb3JtICE9PSBcIm5vbmVcIikgcmV0dXJuIHRydWU7XG4gIGlmIChcIndlYmtpdFRyYW5zZm9ybVwiIGluIHN0eWxlICYmIHN0eWxlLndlYmtpdFRyYW5zZm9ybSAhPT0gXCJub25lXCIpIHJldHVybiB0cnVlO1xuICBpZiAoXCJtaXhCbGVuZE1vZGVcIiBpbiBzdHlsZSAmJiBzdHlsZS5taXhCbGVuZE1vZGUgIT09IFwibm9ybWFsXCIpIHJldHVybiB0cnVlO1xuICBpZiAoXCJmaWx0ZXJcIiBpbiBzdHlsZSAmJiBzdHlsZS5maWx0ZXIgIT09IFwibm9uZVwiKSByZXR1cm4gdHJ1ZTtcbiAgaWYgKFwid2Via2l0RmlsdGVyXCIgaW4gc3R5bGUgJiYgc3R5bGUud2Via2l0RmlsdGVyICE9PSBcIm5vbmVcIikgcmV0dXJuIHRydWU7XG4gIGlmIChcImlzb2xhdGlvblwiIGluIHN0eWxlICYmIHN0eWxlLmlzb2xhdGlvbiA9PT0gXCJpc29sYXRlXCIpIHJldHVybiB0cnVlO1xuICBpZiAocHJvcHMudGVzdChzdHlsZS53aWxsQ2hhbmdlKSkgcmV0dXJuIHRydWU7XG4gIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgaWYgKHN0eWxlLndlYmtpdE92ZXJmbG93U2Nyb2xsaW5nID09PSBcInRvdWNoXCIpIHJldHVybiB0cnVlO1xuICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKiBAcGFyYW0ge0hUTUxFbGVtZW50W119IG5vZGVzICovXG5mdW5jdGlvbiBmaW5kX3N0YWNraW5nX2NvbnRleHQobm9kZXMpIHtcbiAgbGV0IGkgPSBub2Rlcy5sZW5ndGg7XG4gIHdoaWxlIChpLS0pIHtcbiAgICBjb25zdCBub2RlID0gbm9kZXNbaV07XG4gICAgYXNzZXJ0KG5vZGUsIFwiTWlzc2luZyBub2RlXCIpO1xuICAgIGlmIChjcmVhdGVzX3N0YWNraW5nX2NvbnRleHQobm9kZSkpIHJldHVybiBub2RlO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG4vKiogQHBhcmFtIHtIVE1MRWxlbWVudH0gbm9kZSAqL1xuZnVuY3Rpb24gZ2V0X3pfaW5kZXgobm9kZSkge1xuICByZXR1cm4gbm9kZSAmJiBOdW1iZXIoZ2V0Q29tcHV0ZWRTdHlsZShub2RlKS56SW5kZXgpIHx8IDA7XG59XG5cbi8qKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBub2RlICovXG5mdW5jdGlvbiBnZXRfYW5jZXN0b3JzKG5vZGUpIHtcbiAgY29uc3QgYW5jZXN0b3JzID0gW107XG4gIHdoaWxlIChub2RlKSB7XG4gICAgYW5jZXN0b3JzLnB1c2gobm9kZSk7XG4gICAgbm9kZSA9IGdldF9wYXJlbnQobm9kZSk7XG4gIH1cbiAgcmV0dXJuIGFuY2VzdG9yczsgLy8gWyBub2RlLCAuLi4gPGJvZHk+LCA8aHRtbD4sIGRvY3VtZW50IF1cbn1cblxuLyoqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IG5vZGUgKi9cbmZ1bmN0aW9uIGdldF9wYXJlbnQobm9kZSkge1xuICB2YXIgX25vZGUkcGFyZW50Tm9kZTtcbiAgLy8gQHRzLWlnbm9yZVxuICByZXR1cm4gKChfbm9kZSRwYXJlbnROb2RlID0gbm9kZS5wYXJlbnROb2RlKSA9PT0gbnVsbCB8fCBfbm9kZSRwYXJlbnROb2RlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfbm9kZSRwYXJlbnROb2RlLmhvc3QpIHx8IG5vZGUucGFyZW50Tm9kZTtcbn1cblxuY29uc3QgRVhDRUVERURfSE9SSVpPTlRBTF9NSU4gPSAwYjAwMDE7XG5jb25zdCBFWENFRURFRF9IT1JJWk9OVEFMX01BWCA9IDBiMDAxMDtcbmNvbnN0IEVYQ0VFREVEX1ZFUlRJQ0FMX01JTiA9IDBiMDEwMDtcbmNvbnN0IEVYQ0VFREVEX1ZFUlRJQ0FMX01BWCA9IDBiMTAwMDtcbmNvbnN0IGlzQ29hcnNlUG9pbnRlciA9IGdldElucHV0VHlwZSgpID09PSBcImNvYXJzZVwiO1xubGV0IGludGVyc2VjdGluZ0hhbmRsZXMgPSBbXTtcbmxldCBpc1BvaW50ZXJEb3duID0gZmFsc2U7XG5sZXQgb3duZXJEb2N1bWVudENvdW50cyA9IG5ldyBNYXAoKTtcbmxldCBwYW5lbENvbnN0cmFpbnRGbGFncyA9IG5ldyBNYXAoKTtcbmNvbnN0IHJlZ2lzdGVyZWRSZXNpemVIYW5kbGVycyA9IG5ldyBTZXQoKTtcbmZ1bmN0aW9uIHJlZ2lzdGVyUmVzaXplSGFuZGxlKHJlc2l6ZUhhbmRsZUlkLCBlbGVtZW50LCBkaXJlY3Rpb24sIGhpdEFyZWFNYXJnaW5zLCBzZXRSZXNpemVIYW5kbGVyU3RhdGUpIHtcbiAgdmFyIF9vd25lckRvY3VtZW50Q291bnRzJDtcbiAgY29uc3Qge1xuICAgIG93bmVyRG9jdW1lbnRcbiAgfSA9IGVsZW1lbnQ7XG4gIGNvbnN0IGRhdGEgPSB7XG4gICAgZGlyZWN0aW9uLFxuICAgIGVsZW1lbnQsXG4gICAgaGl0QXJlYU1hcmdpbnMsXG4gICAgc2V0UmVzaXplSGFuZGxlclN0YXRlXG4gIH07XG4gIGNvbnN0IGNvdW50ID0gKF9vd25lckRvY3VtZW50Q291bnRzJCA9IG93bmVyRG9jdW1lbnRDb3VudHMuZ2V0KG93bmVyRG9jdW1lbnQpKSAhPT0gbnVsbCAmJiBfb3duZXJEb2N1bWVudENvdW50cyQgIT09IHZvaWQgMCA/IF9vd25lckRvY3VtZW50Q291bnRzJCA6IDA7XG4gIG93bmVyRG9jdW1lbnRDb3VudHMuc2V0KG93bmVyRG9jdW1lbnQsIGNvdW50ICsgMSk7XG4gIHJlZ2lzdGVyZWRSZXNpemVIYW5kbGVycy5hZGQoZGF0YSk7XG4gIHVwZGF0ZUxpc3RlbmVycygpO1xuICByZXR1cm4gZnVuY3Rpb24gdW5yZWdpc3RlclJlc2l6ZUhhbmRsZSgpIHtcbiAgICB2YXIgX293bmVyRG9jdW1lbnRDb3VudHMkMjtcbiAgICBwYW5lbENvbnN0cmFpbnRGbGFncy5kZWxldGUocmVzaXplSGFuZGxlSWQpO1xuICAgIHJlZ2lzdGVyZWRSZXNpemVIYW5kbGVycy5kZWxldGUoZGF0YSk7XG4gICAgY29uc3QgY291bnQgPSAoX293bmVyRG9jdW1lbnRDb3VudHMkMiA9IG93bmVyRG9jdW1lbnRDb3VudHMuZ2V0KG93bmVyRG9jdW1lbnQpKSAhPT0gbnVsbCAmJiBfb3duZXJEb2N1bWVudENvdW50cyQyICE9PSB2b2lkIDAgPyBfb3duZXJEb2N1bWVudENvdW50cyQyIDogMTtcbiAgICBvd25lckRvY3VtZW50Q291bnRzLnNldChvd25lckRvY3VtZW50LCBjb3VudCAtIDEpO1xuICAgIHVwZGF0ZUxpc3RlbmVycygpO1xuICAgIGlmIChjb3VudCA9PT0gMSkge1xuICAgICAgb3duZXJEb2N1bWVudENvdW50cy5kZWxldGUob3duZXJEb2N1bWVudCk7XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gaGFuZGxlUG9pbnRlckRvd24oZXZlbnQpIHtcbiAgY29uc3Qge1xuICAgIHRhcmdldFxuICB9ID0gZXZlbnQ7XG4gIGNvbnN0IHtcbiAgICB4LFxuICAgIHlcbiAgfSA9IGdldFJlc2l6ZUV2ZW50Q29vcmRpbmF0ZXMoZXZlbnQpO1xuICBpc1BvaW50ZXJEb3duID0gdHJ1ZTtcbiAgcmVjYWxjdWxhdGVJbnRlcnNlY3RpbmdIYW5kbGVzKHtcbiAgICB0YXJnZXQsXG4gICAgeCxcbiAgICB5XG4gIH0pO1xuICB1cGRhdGVMaXN0ZW5lcnMoKTtcbiAgaWYgKGludGVyc2VjdGluZ0hhbmRsZXMubGVuZ3RoID4gMCkge1xuICAgIHVwZGF0ZVJlc2l6ZUhhbmRsZXJTdGF0ZXMoXCJkb3duXCIsIGV2ZW50KTtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICB9XG59XG5mdW5jdGlvbiBoYW5kbGVQb2ludGVyTW92ZShldmVudCkge1xuICBjb25zdCB7XG4gICAgeCxcbiAgICB5XG4gIH0gPSBnZXRSZXNpemVFdmVudENvb3JkaW5hdGVzKGV2ZW50KTtcbiAgaWYgKCFpc1BvaW50ZXJEb3duKSB7XG4gICAgY29uc3Qge1xuICAgICAgdGFyZ2V0XG4gICAgfSA9IGV2ZW50O1xuXG4gICAgLy8gUmVjYWxjdWxhdGUgaW50ZXJzZWN0aW5nIGhhbmRsZXMgd2hlbmV2ZXIgdGhlIHBvaW50ZXIgbW92ZXMsIGV4Y2VwdCBpZiBpdCBoYXMgYWxyZWFkeSBiZWVuIHByZXNzZWRcbiAgICAvLyBhdCB0aGF0IHBvaW50LCB0aGUgaGFuZGxlcyBtYXkgbm90IG1vdmUgd2l0aCB0aGUgcG9pbnRlciAoZGVwZW5kaW5nIG9uIGNvbnN0cmFpbnRzKVxuICAgIC8vIGJ1dCB0aGUgc2FtZSBzZXQgb2YgYWN0aXZlIGhhbmRsZXMgc2hvdWxkIGJlIGxvY2tlZCB1bnRpbCB0aGUgcG9pbnRlciBpcyByZWxlYXNlZFxuICAgIHJlY2FsY3VsYXRlSW50ZXJzZWN0aW5nSGFuZGxlcyh7XG4gICAgICB0YXJnZXQsXG4gICAgICB4LFxuICAgICAgeVxuICAgIH0pO1xuICB9XG4gIHVwZGF0ZVJlc2l6ZUhhbmRsZXJTdGF0ZXMoXCJtb3ZlXCIsIGV2ZW50KTtcblxuICAvLyBVcGRhdGUgY3Vyc29yIGJhc2VkIG9uIHJldHVybiB2YWx1ZShzKSBmcm9tIGFjdGl2ZSBoYW5kbGVzXG4gIHVwZGF0ZUN1cnNvcigpO1xuICBpZiAoaW50ZXJzZWN0aW5nSGFuZGxlcy5sZW5ndGggPiAwKSB7XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgfVxufVxuZnVuY3Rpb24gaGFuZGxlUG9pbnRlclVwKGV2ZW50KSB7XG4gIGNvbnN0IHtcbiAgICB0YXJnZXRcbiAgfSA9IGV2ZW50O1xuICBjb25zdCB7XG4gICAgeCxcbiAgICB5XG4gIH0gPSBnZXRSZXNpemVFdmVudENvb3JkaW5hdGVzKGV2ZW50KTtcbiAgcGFuZWxDb25zdHJhaW50RmxhZ3MuY2xlYXIoKTtcbiAgaXNQb2ludGVyRG93biA9IGZhbHNlO1xuICBpZiAoaW50ZXJzZWN0aW5nSGFuZGxlcy5sZW5ndGggPiAwKSB7XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgfVxuICB1cGRhdGVSZXNpemVIYW5kbGVyU3RhdGVzKFwidXBcIiwgZXZlbnQpO1xuICByZWNhbGN1bGF0ZUludGVyc2VjdGluZ0hhbmRsZXMoe1xuICAgIHRhcmdldCxcbiAgICB4LFxuICAgIHlcbiAgfSk7XG4gIHVwZGF0ZUN1cnNvcigpO1xuICB1cGRhdGVMaXN0ZW5lcnMoKTtcbn1cbmZ1bmN0aW9uIHJlY2FsY3VsYXRlSW50ZXJzZWN0aW5nSGFuZGxlcyh7XG4gIHRhcmdldCxcbiAgeCxcbiAgeVxufSkge1xuICBpbnRlcnNlY3RpbmdIYW5kbGVzLnNwbGljZSgwKTtcbiAgbGV0IHRhcmdldEVsZW1lbnQgPSBudWxsO1xuICBpZiAodGFyZ2V0IGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpIHtcbiAgICB0YXJnZXRFbGVtZW50ID0gdGFyZ2V0O1xuICB9XG4gIHJlZ2lzdGVyZWRSZXNpemVIYW5kbGVycy5mb3JFYWNoKGRhdGEgPT4ge1xuICAgIGNvbnN0IHtcbiAgICAgIGVsZW1lbnQ6IGRyYWdIYW5kbGVFbGVtZW50LFxuICAgICAgaGl0QXJlYU1hcmdpbnNcbiAgICB9ID0gZGF0YTtcbiAgICBjb25zdCBkcmFnSGFuZGxlUmVjdCA9IGRyYWdIYW5kbGVFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIGNvbnN0IHtcbiAgICAgIGJvdHRvbSxcbiAgICAgIGxlZnQsXG4gICAgICByaWdodCxcbiAgICAgIHRvcFxuICAgIH0gPSBkcmFnSGFuZGxlUmVjdDtcbiAgICBjb25zdCBtYXJnaW4gPSBpc0NvYXJzZVBvaW50ZXIgPyBoaXRBcmVhTWFyZ2lucy5jb2Fyc2UgOiBoaXRBcmVhTWFyZ2lucy5maW5lO1xuICAgIGNvbnN0IGV2ZW50SW50ZXJzZWN0cyA9IHggPj0gbGVmdCAtIG1hcmdpbiAmJiB4IDw9IHJpZ2h0ICsgbWFyZ2luICYmIHkgPj0gdG9wIC0gbWFyZ2luICYmIHkgPD0gYm90dG9tICsgbWFyZ2luO1xuICAgIGlmIChldmVudEludGVyc2VjdHMpIHtcbiAgICAgIC8vIFRSSUNLWVxuICAgICAgLy8gV2UgbGlzdGVuIGZvciBwb2ludGVycyBldmVudHMgYXQgdGhlIHJvb3QgaW4gb3JkZXIgdG8gc3VwcG9ydCBoaXQgYXJlYSBtYXJnaW5zXG4gICAgICAvLyAoZGV0ZXJtaW5pbmcgd2hlbiB0aGUgcG9pbnRlciBpcyBjbG9zZSBlbm91Z2ggdG8gYW4gZWxlbWVudCB0byBiZSBjb25zaWRlcmVkIGEgXCJoaXRcIilcbiAgICAgIC8vIENsaWNraW5nIG9uIGFuIGVsZW1lbnQgXCJhYm92ZVwiIGEgaGFuZGxlIChlLmcuIGEgbW9kYWwpIHNob3VsZCBwcmV2ZW50IGEgaGl0IHRob3VnaFxuICAgICAgLy8gc28gYXQgdGhpcyBwb2ludCB3ZSBuZWVkIHRvIGNvbXBhcmUgc3RhY2tpbmcgb3JkZXIgb2YgYSBwb3RlbnRpYWxseSBpbnRlcnNlY3RpbmcgZHJhZyBoYW5kbGUsXG4gICAgICAvLyBhbmQgdGhlIGVsZW1lbnQgdGhhdCB3YXMgYWN0dWFsbHkgY2xpY2tlZC90b3VjaGVkXG4gICAgICBpZiAodGFyZ2V0RWxlbWVudCAhPT0gbnVsbCAmJiBkcmFnSGFuZGxlRWxlbWVudCAhPT0gdGFyZ2V0RWxlbWVudCAmJiAhZHJhZ0hhbmRsZUVsZW1lbnQuY29udGFpbnModGFyZ2V0RWxlbWVudCkgJiYgIXRhcmdldEVsZW1lbnQuY29udGFpbnMoZHJhZ0hhbmRsZUVsZW1lbnQpICYmXG4gICAgICAvLyBDYWxjdWxhdGluZyBzdGFja2luZyBvcmRlciBoYXMgYSBjb3N0LCBzbyB3ZSBzaG91bGQgYXZvaWQgaXQgaWYgcG9zc2libGVcbiAgICAgIC8vIFRoYXQgaXMgd2h5IHdlIG9ubHkgY2hlY2sgcG90ZW50aWFsbHkgaW50ZXJzZWN0aW5nIGhhbmRsZXMsXG4gICAgICAvLyBhbmQgd2h5IHdlIHNraXAgaWYgdGhlIGV2ZW50IHRhcmdldCBpcyB3aXRoaW4gdGhlIGhhbmRsZSdzIERPTVxuICAgICAgY29tcGFyZSh0YXJnZXRFbGVtZW50LCBkcmFnSGFuZGxlRWxlbWVudCkgPiAwKSB7XG4gICAgICAgIC8vIElmIHRoZSB0YXJnZXQgaXMgYWJvdmUgdGhlIGRyYWcgaGFuZGxlLCB0aGVuIHdlIGFsc28gbmVlZCB0byBjb25maXJtIHRoZXkgb3ZlcmxhcFxuICAgICAgICAvLyBJZiB0aGV5IGFyZSBiZXNpZGUgZWFjaCBvdGhlciAoZS5nLiBhIHBhbmVsIGFuZCBpdHMgZHJhZyBoYW5kbGUpIHRoZW4gdGhlIGhhbmRsZSBpcyBzdGlsbCBpbnRlcmFjdGl2ZVxuICAgICAgICAvL1xuICAgICAgICAvLyBJdCdzIG5vdCBlbm91Z2ggdG8gY29tcGFyZSBvbmx5IHRoZSB0YXJnZXRcbiAgICAgICAgLy8gVGhlIHRhcmdldCBtaWdodCBiZSBhIHNtYWxsIGVsZW1lbnQgaW5zaWRlIG9mIGEgbGFyZ2VyIGNvbnRhaW5lclxuICAgICAgICAvLyAoRm9yIGV4YW1wbGUsIGEgU1BBTiBvciBhIERJViBpbnNpZGUgb2YgYSBsYXJnZXIgbW9kYWwgZGlhbG9nKVxuICAgICAgICBsZXQgY3VycmVudEVsZW1lbnQgPSB0YXJnZXRFbGVtZW50O1xuICAgICAgICBsZXQgZGlkSW50ZXJzZWN0ID0gZmFsc2U7XG4gICAgICAgIHdoaWxlIChjdXJyZW50RWxlbWVudCkge1xuICAgICAgICAgIGlmIChjdXJyZW50RWxlbWVudC5jb250YWlucyhkcmFnSGFuZGxlRWxlbWVudCkpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH0gZWxzZSBpZiAoaW50ZXJzZWN0cyhjdXJyZW50RWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSwgZHJhZ0hhbmRsZVJlY3QsIHRydWUpKSB7XG4gICAgICAgICAgICBkaWRJbnRlcnNlY3QgPSB0cnVlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGN1cnJlbnRFbGVtZW50ID0gY3VycmVudEVsZW1lbnQucGFyZW50RWxlbWVudDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGlkSW50ZXJzZWN0KSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpbnRlcnNlY3RpbmdIYW5kbGVzLnB1c2goZGF0YSk7XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIHJlcG9ydENvbnN0cmFpbnRzVmlvbGF0aW9uKHJlc2l6ZUhhbmRsZUlkLCBmbGFnKSB7XG4gIHBhbmVsQ29uc3RyYWludEZsYWdzLnNldChyZXNpemVIYW5kbGVJZCwgZmxhZyk7XG59XG5mdW5jdGlvbiB1cGRhdGVDdXJzb3IoKSB7XG4gIGxldCBpbnRlcnNlY3RzSG9yaXpvbnRhbCA9IGZhbHNlO1xuICBsZXQgaW50ZXJzZWN0c1ZlcnRpY2FsID0gZmFsc2U7XG4gIGludGVyc2VjdGluZ0hhbmRsZXMuZm9yRWFjaChkYXRhID0+IHtcbiAgICBjb25zdCB7XG4gICAgICBkaXJlY3Rpb25cbiAgICB9ID0gZGF0YTtcbiAgICBpZiAoZGlyZWN0aW9uID09PSBcImhvcml6b250YWxcIikge1xuICAgICAgaW50ZXJzZWN0c0hvcml6b250YWwgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBpbnRlcnNlY3RzVmVydGljYWwgPSB0cnVlO1xuICAgIH1cbiAgfSk7XG4gIGxldCBjb25zdHJhaW50RmxhZ3MgPSAwO1xuICBwYW5lbENvbnN0cmFpbnRGbGFncy5mb3JFYWNoKGZsYWcgPT4ge1xuICAgIGNvbnN0cmFpbnRGbGFncyB8PSBmbGFnO1xuICB9KTtcbiAgaWYgKGludGVyc2VjdHNIb3Jpem9udGFsICYmIGludGVyc2VjdHNWZXJ0aWNhbCkge1xuICAgIHNldEdsb2JhbEN1cnNvclN0eWxlKFwiaW50ZXJzZWN0aW9uXCIsIGNvbnN0cmFpbnRGbGFncyk7XG4gIH0gZWxzZSBpZiAoaW50ZXJzZWN0c0hvcml6b250YWwpIHtcbiAgICBzZXRHbG9iYWxDdXJzb3JTdHlsZShcImhvcml6b250YWxcIiwgY29uc3RyYWludEZsYWdzKTtcbiAgfSBlbHNlIGlmIChpbnRlcnNlY3RzVmVydGljYWwpIHtcbiAgICBzZXRHbG9iYWxDdXJzb3JTdHlsZShcInZlcnRpY2FsXCIsIGNvbnN0cmFpbnRGbGFncyk7XG4gIH0gZWxzZSB7XG4gICAgcmVzZXRHbG9iYWxDdXJzb3JTdHlsZSgpO1xuICB9XG59XG5mdW5jdGlvbiB1cGRhdGVMaXN0ZW5lcnMoKSB7XG4gIG93bmVyRG9jdW1lbnRDb3VudHMuZm9yRWFjaCgoXywgb3duZXJEb2N1bWVudCkgPT4ge1xuICAgIGNvbnN0IHtcbiAgICAgIGJvZHlcbiAgICB9ID0gb3duZXJEb2N1bWVudDtcbiAgICBib2R5LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjb250ZXh0bWVudVwiLCBoYW5kbGVQb2ludGVyVXApO1xuICAgIGJvZHkucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNlZG93blwiLCBoYW5kbGVQb2ludGVyRG93bik7XG4gICAgYm9keS5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2VsZWF2ZVwiLCBoYW5kbGVQb2ludGVyTW92ZSk7XG4gICAgYm9keS5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2Vtb3ZlXCIsIGhhbmRsZVBvaW50ZXJNb3ZlKTtcbiAgICBib2R5LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ0b3VjaG1vdmVcIiwgaGFuZGxlUG9pbnRlck1vdmUpO1xuICAgIGJvZHkucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInRvdWNoc3RhcnRcIiwgaGFuZGxlUG9pbnRlckRvd24pO1xuICB9KTtcbiAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZXVwXCIsIGhhbmRsZVBvaW50ZXJVcCk7XG4gIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwidG91Y2hjYW5jZWxcIiwgaGFuZGxlUG9pbnRlclVwKTtcbiAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ0b3VjaGVuZFwiLCBoYW5kbGVQb2ludGVyVXApO1xuICBpZiAocmVnaXN0ZXJlZFJlc2l6ZUhhbmRsZXJzLnNpemUgPiAwKSB7XG4gICAgaWYgKGlzUG9pbnRlckRvd24pIHtcbiAgICAgIGlmIChpbnRlcnNlY3RpbmdIYW5kbGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgb3duZXJEb2N1bWVudENvdW50cy5mb3JFYWNoKChjb3VudCwgb3duZXJEb2N1bWVudCkgPT4ge1xuICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgIGJvZHlcbiAgICAgICAgICB9ID0gb3duZXJEb2N1bWVudDtcbiAgICAgICAgICBpZiAoY291bnQgPiAwKSB7XG4gICAgICAgICAgICBib2R5LmFkZEV2ZW50TGlzdGVuZXIoXCJjb250ZXh0bWVudVwiLCBoYW5kbGVQb2ludGVyVXApO1xuICAgICAgICAgICAgYm9keS5hZGRFdmVudExpc3RlbmVyKFwibW91c2VsZWF2ZVwiLCBoYW5kbGVQb2ludGVyTW92ZSk7XG4gICAgICAgICAgICBib2R5LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZW1vdmVcIiwgaGFuZGxlUG9pbnRlck1vdmUpO1xuICAgICAgICAgICAgYm9keS5hZGRFdmVudExpc3RlbmVyKFwidG91Y2htb3ZlXCIsIGhhbmRsZVBvaW50ZXJNb3ZlLCB7XG4gICAgICAgICAgICAgIHBhc3NpdmU6IGZhbHNlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZXVwXCIsIGhhbmRsZVBvaW50ZXJVcCk7XG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNoY2FuY2VsXCIsIGhhbmRsZVBvaW50ZXJVcCk7XG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNoZW5kXCIsIGhhbmRsZVBvaW50ZXJVcCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG93bmVyRG9jdW1lbnRDb3VudHMuZm9yRWFjaCgoY291bnQsIG93bmVyRG9jdW1lbnQpID0+IHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIGJvZHlcbiAgICAgICAgfSA9IG93bmVyRG9jdW1lbnQ7XG4gICAgICAgIGlmIChjb3VudCA+IDApIHtcbiAgICAgICAgICBib2R5LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWRvd25cIiwgaGFuZGxlUG9pbnRlckRvd24pO1xuICAgICAgICAgIGJvZHkuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLCBoYW5kbGVQb2ludGVyTW92ZSk7XG4gICAgICAgICAgYm9keS5hZGRFdmVudExpc3RlbmVyKFwidG91Y2htb3ZlXCIsIGhhbmRsZVBvaW50ZXJNb3ZlLCB7XG4gICAgICAgICAgICBwYXNzaXZlOiBmYWxzZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGJvZHkuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNoc3RhcnRcIiwgaGFuZGxlUG9pbnRlckRvd24pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHVwZGF0ZVJlc2l6ZUhhbmRsZXJTdGF0ZXMoYWN0aW9uLCBldmVudCkge1xuICByZWdpc3RlcmVkUmVzaXplSGFuZGxlcnMuZm9yRWFjaChkYXRhID0+IHtcbiAgICBjb25zdCB7XG4gICAgICBzZXRSZXNpemVIYW5kbGVyU3RhdGVcbiAgICB9ID0gZGF0YTtcbiAgICBjb25zdCBpc0FjdGl2ZSA9IGludGVyc2VjdGluZ0hhbmRsZXMuaW5jbHVkZXMoZGF0YSk7XG4gICAgc2V0UmVzaXplSGFuZGxlclN0YXRlKGFjdGlvbiwgaXNBY3RpdmUsIGV2ZW50KTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGFzc2VydChleHBlY3RlZENvbmRpdGlvbiwgbWVzc2FnZSkge1xuICBpZiAoIWV4cGVjdGVkQ29uZGl0aW9uKSB7XG4gICAgY29uc29sZS5lcnJvcihtZXNzYWdlKTtcbiAgICB0aHJvdyBFcnJvcihtZXNzYWdlKTtcbiAgfVxufVxuXG5jb25zdCBQUkVDSVNJT04gPSAxMDtcblxuZnVuY3Rpb24gZnV6enlDb21wYXJlTnVtYmVycyhhY3R1YWwsIGV4cGVjdGVkLCBmcmFjdGlvbkRpZ2l0cyA9IFBSRUNJU0lPTikge1xuICBhY3R1YWwgPSBwYXJzZUZsb2F0KGFjdHVhbC50b0ZpeGVkKGZyYWN0aW9uRGlnaXRzKSk7XG4gIGV4cGVjdGVkID0gcGFyc2VGbG9hdChleHBlY3RlZC50b0ZpeGVkKGZyYWN0aW9uRGlnaXRzKSk7XG4gIGNvbnN0IGRlbHRhID0gYWN0dWFsIC0gZXhwZWN0ZWQ7XG4gIGlmIChkZWx0YSA9PT0gMCkge1xuICAgIHJldHVybiAwO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBkZWx0YSA+IDAgPyAxIDogLTE7XG4gIH1cbn1cblxuZnVuY3Rpb24gZnV6enlOdW1iZXJzRXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgZnJhY3Rpb25EaWdpdHMpIHtcbiAgcmV0dXJuIGZ1enp5Q29tcGFyZU51bWJlcnMoYWN0dWFsLCBleHBlY3RlZCwgZnJhY3Rpb25EaWdpdHMpID09PSAwO1xufVxuXG5mdW5jdGlvbiBmdXp6eUxheW91dHNFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBmcmFjdGlvbkRpZ2l0cykge1xuICBpZiAoYWN0dWFsLmxlbmd0aCAhPT0gZXhwZWN0ZWQubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBhY3R1YWwubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgY29uc3QgYWN0dWFsU2l6ZSA9IGFjdHVhbFtpbmRleF07XG4gICAgY29uc3QgZXhwZWN0ZWRTaXplID0gZXhwZWN0ZWRbaW5kZXhdO1xuICAgIGlmICghZnV6enlOdW1iZXJzRXF1YWwoYWN0dWFsU2l6ZSwgZXhwZWN0ZWRTaXplLCBmcmFjdGlvbkRpZ2l0cykpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbi8vIFBhbmVsIHNpemUgbXVzdCBiZSBpbiBwZXJjZW50YWdlczsgcGl4ZWwgdmFsdWVzIHNob3VsZCBiZSBwcmUtY29udmVydGVkXG5mdW5jdGlvbiByZXNpemVQYW5lbCh7XG4gIHBhbmVsQ29uc3RyYWludHM6IHBhbmVsQ29uc3RyYWludHNBcnJheSxcbiAgcGFuZWxJbmRleCxcbiAgc2l6ZVxufSkge1xuICBjb25zdCBwYW5lbENvbnN0cmFpbnRzID0gcGFuZWxDb25zdHJhaW50c0FycmF5W3BhbmVsSW5kZXhdO1xuICBhc3NlcnQocGFuZWxDb25zdHJhaW50cyAhPSBudWxsLCBgUGFuZWwgY29uc3RyYWludHMgbm90IGZvdW5kIGZvciBpbmRleCAke3BhbmVsSW5kZXh9YCk7XG4gIGxldCB7XG4gICAgY29sbGFwc2VkU2l6ZSA9IDAsXG4gICAgY29sbGFwc2libGUsXG4gICAgbWF4U2l6ZSA9IDEwMCxcbiAgICBtaW5TaXplID0gMFxuICB9ID0gcGFuZWxDb25zdHJhaW50cztcbiAgaWYgKGZ1enp5Q29tcGFyZU51bWJlcnMoc2l6ZSwgbWluU2l6ZSkgPCAwKSB7XG4gICAgaWYgKGNvbGxhcHNpYmxlKSB7XG4gICAgICAvLyBDb2xsYXBzaWJsZSBwYW5lbHMgc2hvdWxkIHNuYXAgY2xvc2VkIG9yIG9wZW4gb25seSBvbmNlIHRoZXkgY3Jvc3MgdGhlIGhhbGZ3YXkgcG9pbnQgYmV0d2VlbiBjb2xsYXBzZWQgYW5kIG1pbiBzaXplLlxuICAgICAgY29uc3QgaGFsZndheVBvaW50ID0gKGNvbGxhcHNlZFNpemUgKyBtaW5TaXplKSAvIDI7XG4gICAgICBpZiAoZnV6enlDb21wYXJlTnVtYmVycyhzaXplLCBoYWxmd2F5UG9pbnQpIDwgMCkge1xuICAgICAgICBzaXplID0gY29sbGFwc2VkU2l6ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNpemUgPSBtaW5TaXplO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzaXplID0gbWluU2l6ZTtcbiAgICB9XG4gIH1cbiAgc2l6ZSA9IE1hdGgubWluKG1heFNpemUsIHNpemUpO1xuICBzaXplID0gcGFyc2VGbG9hdChzaXplLnRvRml4ZWQoUFJFQ0lTSU9OKSk7XG4gIHJldHVybiBzaXplO1xufVxuXG4vLyBBbGwgdW5pdHMgbXVzdCBiZSBpbiBwZXJjZW50YWdlczsgcGl4ZWwgdmFsdWVzIHNob3VsZCBiZSBwcmUtY29udmVydGVkXG5mdW5jdGlvbiBhZGp1c3RMYXlvdXRCeURlbHRhKHtcbiAgZGVsdGEsXG4gIGluaXRpYWxMYXlvdXQsXG4gIHBhbmVsQ29uc3RyYWludHM6IHBhbmVsQ29uc3RyYWludHNBcnJheSxcbiAgcGl2b3RJbmRpY2VzLFxuICBwcmV2TGF5b3V0LFxuICB0cmlnZ2VyXG59KSB7XG4gIGlmIChmdXp6eU51bWJlcnNFcXVhbChkZWx0YSwgMCkpIHtcbiAgICByZXR1cm4gaW5pdGlhbExheW91dDtcbiAgfVxuICBjb25zdCBuZXh0TGF5b3V0ID0gWy4uLmluaXRpYWxMYXlvdXRdO1xuICBjb25zdCBbZmlyc3RQaXZvdEluZGV4LCBzZWNvbmRQaXZvdEluZGV4XSA9IHBpdm90SW5kaWNlcztcbiAgYXNzZXJ0KGZpcnN0UGl2b3RJbmRleCAhPSBudWxsLCBcIkludmFsaWQgZmlyc3QgcGl2b3QgaW5kZXhcIik7XG4gIGFzc2VydChzZWNvbmRQaXZvdEluZGV4ICE9IG51bGwsIFwiSW52YWxpZCBzZWNvbmQgcGl2b3QgaW5kZXhcIik7XG4gIGxldCBkZWx0YUFwcGxpZWQgPSAwO1xuXG4gIC8vIGNvbnN0IERFQlVHID0gW107XG4gIC8vIERFQlVHLnB1c2goYGFkanVzdExheW91dEJ5RGVsdGEoKWApO1xuICAvLyBERUJVRy5wdXNoKGAgIGluaXRpYWxMYXlvdXQ6ICR7aW5pdGlhbExheW91dC5qb2luKFwiLCBcIil9YCk7XG4gIC8vIERFQlVHLnB1c2goYCAgcHJldkxheW91dDogJHtwcmV2TGF5b3V0LmpvaW4oXCIsIFwiKX1gKTtcbiAgLy8gREVCVUcucHVzaChgICBkZWx0YTogJHtkZWx0YX1gKTtcbiAgLy8gREVCVUcucHVzaChgICBwaXZvdEluZGljZXM6ICR7cGl2b3RJbmRpY2VzLmpvaW4oXCIsIFwiKX1gKTtcbiAgLy8gREVCVUcucHVzaChgICB0cmlnZ2VyOiAke3RyaWdnZXJ9YCk7XG4gIC8vIERFQlVHLnB1c2goXCJcIik7XG5cbiAgLy8gQSByZXNpemluZyBwYW5lbCBhZmZlY3RzIHRoZSBwYW5lbHMgYmVmb3JlIG9yIGFmdGVyIGl0LlxuICAvL1xuICAvLyBBIG5lZ2F0aXZlIGRlbHRhIG1lYW5zIHRoZSBwYW5lbChzKSBpbW1lZGlhdGVseSBhZnRlciB0aGUgcmVzaXplIGhhbmRsZSBzaG91bGQgZ3Jvdy9leHBhbmQgYnkgZGVjcmVhc2luZyBpdHMgb2Zmc2V0LlxuICAvLyBPdGhlciBwYW5lbHMgbWF5IGFsc28gbmVlZCB0byBzaHJpbmsvY29udHJhY3QgKGFuZCBzaGlmdCkgdG8gbWFrZSByb29tLCBkZXBlbmRpbmcgb24gdGhlIG1pbiB3ZWlnaHRzLlxuICAvL1xuICAvLyBBIHBvc2l0aXZlIGRlbHRhIG1lYW5zIHRoZSBwYW5lbChzKSBpbW1lZGlhdGVseSBiZWZvcmUgdGhlIHJlc2l6ZSBoYW5kbGUgc2hvdWxkIFwiZXhwYW5kXCIuXG4gIC8vIFRoaXMgaXMgYWNjb21wbGlzaGVkIGJ5IHNocmlua2luZy9jb250cmFjdGluZyAoYW5kIHNoaWZ0aW5nKSBvbmUgb3IgbW9yZSBvZiB0aGUgcGFuZWxzIGFmdGVyIHRoZSByZXNpemUgaGFuZGxlLlxuXG4gIHtcbiAgICAvLyBJZiB0aGlzIGlzIGEgcmVzaXplIHRyaWdnZXJlZCBieSBhIGtleWJvYXJkIGV2ZW50LCBvdXIgbG9naWMgZm9yIGV4cGFuZGluZy9jb2xsYXBzaW5nIGlzIGRpZmZlcmVudC5cbiAgICAvLyBXZSBubyBsb25nZXIgY2hlY2sgdGhlIGhhbGZ3YXkgdGhyZXNob2xkIGJlY2F1c2UgdGhpcyBtYXkgcHJldmVudCB0aGUgcGFuZWwgZnJvbSBleHBhbmRpbmcgYXQgYWxsLlxuICAgIGlmICh0cmlnZ2VyID09PSBcImtleWJvYXJkXCIpIHtcbiAgICAgIHtcbiAgICAgICAgLy8gQ2hlY2sgaWYgd2Ugc2hvdWxkIGV4cGFuZCBhIGNvbGxhcHNlZCBwYW5lbFxuICAgICAgICBjb25zdCBpbmRleCA9IGRlbHRhIDwgMCA/IHNlY29uZFBpdm90SW5kZXggOiBmaXJzdFBpdm90SW5kZXg7XG4gICAgICAgIGNvbnN0IHBhbmVsQ29uc3RyYWludHMgPSBwYW5lbENvbnN0cmFpbnRzQXJyYXlbaW5kZXhdO1xuICAgICAgICBhc3NlcnQocGFuZWxDb25zdHJhaW50cywgYFBhbmVsIGNvbnN0cmFpbnRzIG5vdCBmb3VuZCBmb3IgaW5kZXggJHtpbmRleH1gKTtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIGNvbGxhcHNlZFNpemUgPSAwLFxuICAgICAgICAgIGNvbGxhcHNpYmxlLFxuICAgICAgICAgIG1pblNpemUgPSAwXG4gICAgICAgIH0gPSBwYW5lbENvbnN0cmFpbnRzO1xuXG4gICAgICAgIC8vIERFQlVHLnB1c2goYGVkZ2UgY2FzZSBjaGVjayAxOiAke2luZGV4fWApO1xuICAgICAgICAvLyBERUJVRy5wdXNoKGAgIC0+IGNvbGxhcHNpYmxlPyAke2NvbGxhcHNpYmxlfWApO1xuICAgICAgICBpZiAoY29sbGFwc2libGUpIHtcbiAgICAgICAgICBjb25zdCBwcmV2U2l6ZSA9IGluaXRpYWxMYXlvdXRbaW5kZXhdO1xuICAgICAgICAgIGFzc2VydChwcmV2U2l6ZSAhPSBudWxsLCBgUHJldmlvdXMgbGF5b3V0IG5vdCBmb3VuZCBmb3IgcGFuZWwgaW5kZXggJHtpbmRleH1gKTtcbiAgICAgICAgICBpZiAoZnV6enlOdW1iZXJzRXF1YWwocHJldlNpemUsIGNvbGxhcHNlZFNpemUpKSB7XG4gICAgICAgICAgICBjb25zdCBsb2NhbERlbHRhID0gbWluU2l6ZSAtIHByZXZTaXplO1xuICAgICAgICAgICAgLy8gREVCVUcucHVzaChgICAtPiBleHBhbmQgZGVsdGE6ICR7bG9jYWxEZWx0YX1gKTtcblxuICAgICAgICAgICAgaWYgKGZ1enp5Q29tcGFyZU51bWJlcnMobG9jYWxEZWx0YSwgTWF0aC5hYnMoZGVsdGEpKSA+IDApIHtcbiAgICAgICAgICAgICAgZGVsdGEgPSBkZWx0YSA8IDAgPyAwIC0gbG9jYWxEZWx0YSA6IGxvY2FsRGVsdGE7XG4gICAgICAgICAgICAgIC8vIERFQlVHLnB1c2goYCAgLT4gZGVsdGE6ICR7ZGVsdGF9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHtcbiAgICAgICAgLy8gQ2hlY2sgaWYgd2Ugc2hvdWxkIGNvbGxhcHNlIGEgcGFuZWwgYXQgaXRzIG1pbmltdW0gc2l6ZVxuICAgICAgICBjb25zdCBpbmRleCA9IGRlbHRhIDwgMCA/IGZpcnN0UGl2b3RJbmRleCA6IHNlY29uZFBpdm90SW5kZXg7XG4gICAgICAgIGNvbnN0IHBhbmVsQ29uc3RyYWludHMgPSBwYW5lbENvbnN0cmFpbnRzQXJyYXlbaW5kZXhdO1xuICAgICAgICBhc3NlcnQocGFuZWxDb25zdHJhaW50cywgYE5vIHBhbmVsIGNvbnN0cmFpbnRzIGZvdW5kIGZvciBpbmRleCAke2luZGV4fWApO1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgY29sbGFwc2VkU2l6ZSA9IDAsXG4gICAgICAgICAgY29sbGFwc2libGUsXG4gICAgICAgICAgbWluU2l6ZSA9IDBcbiAgICAgICAgfSA9IHBhbmVsQ29uc3RyYWludHM7XG5cbiAgICAgICAgLy8gREVCVUcucHVzaChgZWRnZSBjYXNlIGNoZWNrIDI6ICR7aW5kZXh9YCk7XG4gICAgICAgIC8vIERFQlVHLnB1c2goYCAgLT4gY29sbGFwc2libGU/ICR7Y29sbGFwc2libGV9YCk7XG4gICAgICAgIGlmIChjb2xsYXBzaWJsZSkge1xuICAgICAgICAgIGNvbnN0IHByZXZTaXplID0gaW5pdGlhbExheW91dFtpbmRleF07XG4gICAgICAgICAgYXNzZXJ0KHByZXZTaXplICE9IG51bGwsIGBQcmV2aW91cyBsYXlvdXQgbm90IGZvdW5kIGZvciBwYW5lbCBpbmRleCAke2luZGV4fWApO1xuICAgICAgICAgIGlmIChmdXp6eU51bWJlcnNFcXVhbChwcmV2U2l6ZSwgbWluU2l6ZSkpIHtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsRGVsdGEgPSBwcmV2U2l6ZSAtIGNvbGxhcHNlZFNpemU7XG4gICAgICAgICAgICAvLyBERUJVRy5wdXNoKGAgIC0+IGV4cGFuZCBkZWx0YTogJHtsb2NhbERlbHRhfWApO1xuXG4gICAgICAgICAgICBpZiAoZnV6enlDb21wYXJlTnVtYmVycyhsb2NhbERlbHRhLCBNYXRoLmFicyhkZWx0YSkpID4gMCkge1xuICAgICAgICAgICAgICBkZWx0YSA9IGRlbHRhIDwgMCA/IDAgLSBsb2NhbERlbHRhIDogbG9jYWxEZWx0YTtcbiAgICAgICAgICAgICAgLy8gREVCVUcucHVzaChgICAtPiBkZWx0YTogJHtkZWx0YX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLy8gREVCVUcucHVzaChcIlwiKTtcbiAgfVxuXG4gIHtcbiAgICAvLyBQcmUtY2FsY3VsYXRlIG1heCBhdmFpbGFibGUgZGVsdGEgaW4gdGhlIG9wcG9zaXRlIGRpcmVjdGlvbiBvZiBvdXIgcGl2b3QuXG4gICAgLy8gVGhpcyB3aWxsIGJlIHRoZSBtYXhpbXVtIGFtb3VudCB3ZSdyZSBhbGxvd2VkIHRvIGV4cGFuZC9jb250cmFjdCB0aGUgcGFuZWxzIGluIHRoZSBwcmltYXJ5IGRpcmVjdGlvbi5cbiAgICAvLyBJZiB0aGlzIGFtb3VudCBpcyBsZXNzIHRoYW4gdGhlIHJlcXVlc3RlZCBkZWx0YSwgYWRqdXN0IHRoZSByZXF1ZXN0ZWQgZGVsdGEuXG4gICAgLy8gSWYgdGhpcyBhbW91bnQgaXMgZ3JlYXRlciB0aGFuIHRoZSByZXF1ZXN0ZWQgZGVsdGEsIHRoYXQncyB1c2VmdWwgaW5mb3JtYXRpb24gdG9v4oCTXG4gICAgLy8gYXMgYW4gZXhwYW5kaW5nIHBhbmVsIG1pZ2h0IGNoYW5nZSBmcm9tIGNvbGxhcHNlZCB0byBtaW4gc2l6ZS5cblxuICAgIGNvbnN0IGluY3JlbWVudCA9IGRlbHRhIDwgMCA/IDEgOiAtMTtcbiAgICBsZXQgaW5kZXggPSBkZWx0YSA8IDAgPyBzZWNvbmRQaXZvdEluZGV4IDogZmlyc3RQaXZvdEluZGV4O1xuICAgIGxldCBtYXhBdmFpbGFibGVEZWx0YSA9IDA7XG5cbiAgICAvLyBERUJVRy5wdXNoKFwicHJlIGNhbGMuLi5cIik7XG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIGNvbnN0IHByZXZTaXplID0gaW5pdGlhbExheW91dFtpbmRleF07XG4gICAgICBhc3NlcnQocHJldlNpemUgIT0gbnVsbCwgYFByZXZpb3VzIGxheW91dCBub3QgZm91bmQgZm9yIHBhbmVsIGluZGV4ICR7aW5kZXh9YCk7XG4gICAgICBjb25zdCBtYXhTYWZlU2l6ZSA9IHJlc2l6ZVBhbmVsKHtcbiAgICAgICAgcGFuZWxDb25zdHJhaW50czogcGFuZWxDb25zdHJhaW50c0FycmF5LFxuICAgICAgICBwYW5lbEluZGV4OiBpbmRleCxcbiAgICAgICAgc2l6ZTogMTAwXG4gICAgICB9KTtcbiAgICAgIGNvbnN0IGRlbHRhID0gbWF4U2FmZVNpemUgLSBwcmV2U2l6ZTtcbiAgICAgIC8vIERFQlVHLnB1c2goYCAgJHtpbmRleH06ICR7cHJldlNpemV9IC0+ICR7bWF4U2FmZVNpemV9YCk7XG5cbiAgICAgIG1heEF2YWlsYWJsZURlbHRhICs9IGRlbHRhO1xuICAgICAgaW5kZXggKz0gaW5jcmVtZW50O1xuICAgICAgaWYgKGluZGV4IDwgMCB8fCBpbmRleCA+PSBwYW5lbENvbnN0cmFpbnRzQXJyYXkubGVuZ3RoKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIERFQlVHLnB1c2goYCAgLT4gbWF4IGF2YWlsYWJsZSBkZWx0YTogJHttYXhBdmFpbGFibGVEZWx0YX1gKTtcbiAgICBjb25zdCBtaW5BYnNEZWx0YSA9IE1hdGgubWluKE1hdGguYWJzKGRlbHRhKSwgTWF0aC5hYnMobWF4QXZhaWxhYmxlRGVsdGEpKTtcbiAgICBkZWx0YSA9IGRlbHRhIDwgMCA/IDAgLSBtaW5BYnNEZWx0YSA6IG1pbkFic0RlbHRhO1xuICAgIC8vIERFQlVHLnB1c2goYCAgLT4gYWRqdXN0ZWQgZGVsdGE6ICR7ZGVsdGF9YCk7XG4gICAgLy8gREVCVUcucHVzaChcIlwiKTtcbiAgfVxuXG4gIHtcbiAgICAvLyBEZWx0YSBhZGRlZCB0byBhIHBhbmVsIG5lZWRzIHRvIGJlIHN1YnRyYWN0ZWQgZnJvbSBvdGhlciBwYW5lbHMgKHdpdGhpbiB0aGUgY29uc3RyYWludHMgdGhhdCB0aG9zZSBwYW5lbHMgYWxsb3cpLlxuXG4gICAgY29uc3QgcGl2b3RJbmRleCA9IGRlbHRhIDwgMCA/IGZpcnN0UGl2b3RJbmRleCA6IHNlY29uZFBpdm90SW5kZXg7XG4gICAgbGV0IGluZGV4ID0gcGl2b3RJbmRleDtcbiAgICB3aGlsZSAoaW5kZXggPj0gMCAmJiBpbmRleCA8IHBhbmVsQ29uc3RyYWludHNBcnJheS5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IGRlbHRhUmVtYWluaW5nID0gTWF0aC5hYnMoZGVsdGEpIC0gTWF0aC5hYnMoZGVsdGFBcHBsaWVkKTtcbiAgICAgIGNvbnN0IHByZXZTaXplID0gaW5pdGlhbExheW91dFtpbmRleF07XG4gICAgICBhc3NlcnQocHJldlNpemUgIT0gbnVsbCwgYFByZXZpb3VzIGxheW91dCBub3QgZm91bmQgZm9yIHBhbmVsIGluZGV4ICR7aW5kZXh9YCk7XG4gICAgICBjb25zdCB1bnNhZmVTaXplID0gcHJldlNpemUgLSBkZWx0YVJlbWFpbmluZztcbiAgICAgIGNvbnN0IHNhZmVTaXplID0gcmVzaXplUGFuZWwoe1xuICAgICAgICBwYW5lbENvbnN0cmFpbnRzOiBwYW5lbENvbnN0cmFpbnRzQXJyYXksXG4gICAgICAgIHBhbmVsSW5kZXg6IGluZGV4LFxuICAgICAgICBzaXplOiB1bnNhZmVTaXplXG4gICAgICB9KTtcbiAgICAgIGlmICghZnV6enlOdW1iZXJzRXF1YWwocHJldlNpemUsIHNhZmVTaXplKSkge1xuICAgICAgICBkZWx0YUFwcGxpZWQgKz0gcHJldlNpemUgLSBzYWZlU2l6ZTtcbiAgICAgICAgbmV4dExheW91dFtpbmRleF0gPSBzYWZlU2l6ZTtcbiAgICAgICAgaWYgKGRlbHRhQXBwbGllZC50b1ByZWNpc2lvbigzKS5sb2NhbGVDb21wYXJlKE1hdGguYWJzKGRlbHRhKS50b1ByZWNpc2lvbigzKSwgdW5kZWZpbmVkLCB7XG4gICAgICAgICAgbnVtZXJpYzogdHJ1ZVxuICAgICAgICB9KSA+PSAwKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChkZWx0YSA8IDApIHtcbiAgICAgICAgaW5kZXgtLTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGluZGV4Kys7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8vIERFQlVHLnB1c2goYGFmdGVyIDE6ICR7bmV4dExheW91dC5qb2luKFwiLCBcIil9YCk7XG4gIC8vIERFQlVHLnB1c2goYCAgZGVsdGFBcHBsaWVkOiAke2RlbHRhQXBwbGllZH1gKTtcbiAgLy8gREVCVUcucHVzaChcIlwiKTtcblxuICAvLyBJZiB3ZSB3ZXJlIHVuYWJsZSB0byByZXNpemUgYW55IG9mIHRoZSBwYW5lbHMgcGFuZWxzLCByZXR1cm4gdGhlIHByZXZpb3VzIHN0YXRlLlxuICAvLyBUaGlzIHdpbGwgZXNzZW50aWFsbHkgYmFpbG91dCBhbmQgaWdub3JlIGUuZy4gZHJhZ3MgcGFzdCBhIHBhbmVsJ3MgYm91bmRhcmllc1xuICBpZiAoZnV6enlMYXlvdXRzRXF1YWwocHJldkxheW91dCwgbmV4dExheW91dCkpIHtcbiAgICAvLyBERUJVRy5wdXNoKGBiYWlsb3V0IHRvIHByZXZpb3VzIGxheW91dDogJHtwcmV2TGF5b3V0LmpvaW4oXCIsIFwiKX1gKTtcbiAgICAvLyBjb25zb2xlLmxvZyhERUJVRy5qb2luKFwiXFxuXCIpKTtcblxuICAgIHJldHVybiBwcmV2TGF5b3V0O1xuICB9XG4gIHtcbiAgICAvLyBOb3cgZGlzdHJpYnV0ZSB0aGUgYXBwbGllZCBkZWx0YSB0byB0aGUgcGFuZWxzIGluIHRoZSBvdGhlciBkaXJlY3Rpb25cbiAgICBjb25zdCBwaXZvdEluZGV4ID0gZGVsdGEgPCAwID8gc2Vjb25kUGl2b3RJbmRleCA6IGZpcnN0UGl2b3RJbmRleDtcbiAgICBjb25zdCBwcmV2U2l6ZSA9IGluaXRpYWxMYXlvdXRbcGl2b3RJbmRleF07XG4gICAgYXNzZXJ0KHByZXZTaXplICE9IG51bGwsIGBQcmV2aW91cyBsYXlvdXQgbm90IGZvdW5kIGZvciBwYW5lbCBpbmRleCAke3Bpdm90SW5kZXh9YCk7XG4gICAgY29uc3QgdW5zYWZlU2l6ZSA9IHByZXZTaXplICsgZGVsdGFBcHBsaWVkO1xuICAgIGNvbnN0IHNhZmVTaXplID0gcmVzaXplUGFuZWwoe1xuICAgICAgcGFuZWxDb25zdHJhaW50czogcGFuZWxDb25zdHJhaW50c0FycmF5LFxuICAgICAgcGFuZWxJbmRleDogcGl2b3RJbmRleCxcbiAgICAgIHNpemU6IHVuc2FmZVNpemVcbiAgICB9KTtcblxuICAgIC8vIEFkanVzdCB0aGUgcGl2b3QgcGFuZWwgYmVmb3JlLCBidXQgb25seSBieSB0aGUgYW1vdW50IHRoYXQgc3Vycm91bmRpbmcgcGFuZWxzIHdlcmUgYWJsZSB0byBzaHJpbmsvY29udHJhY3QuXG4gICAgbmV4dExheW91dFtwaXZvdEluZGV4XSA9IHNhZmVTaXplO1xuXG4gICAgLy8gRWRnZSBjYXNlIHdoZXJlIGV4cGFuZGluZyBvciBjb250cmFjdGluZyBvbmUgcGFuZWwgY2F1c2VkIGFub3RoZXIgb25lIHRvIGNoYW5nZSBjb2xsYXBzZWQgc3RhdGVcbiAgICBpZiAoIWZ1enp5TnVtYmVyc0VxdWFsKHNhZmVTaXplLCB1bnNhZmVTaXplKSkge1xuICAgICAgbGV0IGRlbHRhUmVtYWluaW5nID0gdW5zYWZlU2l6ZSAtIHNhZmVTaXplO1xuICAgICAgY29uc3QgcGl2b3RJbmRleCA9IGRlbHRhIDwgMCA/IHNlY29uZFBpdm90SW5kZXggOiBmaXJzdFBpdm90SW5kZXg7XG4gICAgICBsZXQgaW5kZXggPSBwaXZvdEluZGV4O1xuICAgICAgd2hpbGUgKGluZGV4ID49IDAgJiYgaW5kZXggPCBwYW5lbENvbnN0cmFpbnRzQXJyYXkubGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHByZXZTaXplID0gbmV4dExheW91dFtpbmRleF07XG4gICAgICAgIGFzc2VydChwcmV2U2l6ZSAhPSBudWxsLCBgUHJldmlvdXMgbGF5b3V0IG5vdCBmb3VuZCBmb3IgcGFuZWwgaW5kZXggJHtpbmRleH1gKTtcbiAgICAgICAgY29uc3QgdW5zYWZlU2l6ZSA9IHByZXZTaXplICsgZGVsdGFSZW1haW5pbmc7XG4gICAgICAgIGNvbnN0IHNhZmVTaXplID0gcmVzaXplUGFuZWwoe1xuICAgICAgICAgIHBhbmVsQ29uc3RyYWludHM6IHBhbmVsQ29uc3RyYWludHNBcnJheSxcbiAgICAgICAgICBwYW5lbEluZGV4OiBpbmRleCxcbiAgICAgICAgICBzaXplOiB1bnNhZmVTaXplXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIWZ1enp5TnVtYmVyc0VxdWFsKHByZXZTaXplLCBzYWZlU2l6ZSkpIHtcbiAgICAgICAgICBkZWx0YVJlbWFpbmluZyAtPSBzYWZlU2l6ZSAtIHByZXZTaXplO1xuICAgICAgICAgIG5leHRMYXlvdXRbaW5kZXhdID0gc2FmZVNpemU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZ1enp5TnVtYmVyc0VxdWFsKGRlbHRhUmVtYWluaW5nLCAwKSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkZWx0YSA+IDApIHtcbiAgICAgICAgICBpbmRleC0tO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGluZGV4Kys7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLy8gREVCVUcucHVzaChgYWZ0ZXIgMjogJHtuZXh0TGF5b3V0LmpvaW4oXCIsIFwiKX1gKTtcbiAgLy8gREVCVUcucHVzaChgICBkZWx0YUFwcGxpZWQ6ICR7ZGVsdGFBcHBsaWVkfWApO1xuICAvLyBERUJVRy5wdXNoKFwiXCIpO1xuXG4gIGNvbnN0IHRvdGFsU2l6ZSA9IG5leHRMYXlvdXQucmVkdWNlKCh0b3RhbCwgc2l6ZSkgPT4gc2l6ZSArIHRvdGFsLCAwKTtcbiAgLy8gREVCVUcucHVzaChgdG90YWwgc2l6ZTogJHt0b3RhbFNpemV9YCk7XG5cbiAgLy8gSWYgb3VyIG5ldyBsYXlvdXQgZG9lc24ndCBhZGQgdXAgdG8gMTAwJSwgdGhhdCBtZWFucyB0aGUgcmVxdWVzdGVkIGRlbHRhIGNhbid0IGJlIGFwcGxpZWRcbiAgLy8gSW4gdGhhdCBjYXNlLCBmYWxsIGJhY2sgdG8gb3VyIG1vc3QgcmVjZW50IHZhbGlkIGxheW91dFxuICBpZiAoIWZ1enp5TnVtYmVyc0VxdWFsKHRvdGFsU2l6ZSwgMTAwKSkge1xuICAgIC8vIERFQlVHLnB1c2goYGJhaWxvdXQgdG8gcHJldmlvdXMgbGF5b3V0OiAke3ByZXZMYXlvdXQuam9pbihcIiwgXCIpfWApO1xuICAgIC8vIGNvbnNvbGUubG9nKERFQlVHLmpvaW4oXCJcXG5cIikpO1xuXG4gICAgcmV0dXJuIHByZXZMYXlvdXQ7XG4gIH1cblxuICAvLyBjb25zb2xlLmxvZyhERUJVRy5qb2luKFwiXFxuXCIpKTtcbiAgcmV0dXJuIG5leHRMYXlvdXQ7XG59XG5cbmZ1bmN0aW9uIGdldFJlc2l6ZUhhbmRsZUVsZW1lbnRzRm9yR3JvdXAoZ3JvdXBJZCwgc2NvcGUgPSBkb2N1bWVudCkge1xuICByZXR1cm4gQXJyYXkuZnJvbShzY29wZS5xdWVyeVNlbGVjdG9yQWxsKGBbZGF0YS1wYW5lbC1yZXNpemUtaGFuZGxlLWlkXVtkYXRhLXBhbmVsLWdyb3VwLWlkPVwiJHtncm91cElkfVwiXWApKTtcbn1cblxuZnVuY3Rpb24gZ2V0UmVzaXplSGFuZGxlRWxlbWVudEluZGV4KGdyb3VwSWQsIGlkLCBzY29wZSA9IGRvY3VtZW50KSB7XG4gIGNvbnN0IGhhbmRsZXMgPSBnZXRSZXNpemVIYW5kbGVFbGVtZW50c0Zvckdyb3VwKGdyb3VwSWQsIHNjb3BlKTtcbiAgY29uc3QgaW5kZXggPSBoYW5kbGVzLmZpbmRJbmRleChoYW5kbGUgPT4gaGFuZGxlLmdldEF0dHJpYnV0ZShcImRhdGEtcGFuZWwtcmVzaXplLWhhbmRsZS1pZFwiKSA9PT0gaWQpO1xuICByZXR1cm4gaW5kZXggIT09IG51bGwgJiYgaW5kZXggIT09IHZvaWQgMCA/IGluZGV4IDogbnVsbDtcbn1cblxuZnVuY3Rpb24gZGV0ZXJtaW5lUGl2b3RJbmRpY2VzKGdyb3VwSWQsIGRyYWdIYW5kbGVJZCwgcGFuZWxHcm91cEVsZW1lbnQpIHtcbiAgY29uc3QgaW5kZXggPSBnZXRSZXNpemVIYW5kbGVFbGVtZW50SW5kZXgoZ3JvdXBJZCwgZHJhZ0hhbmRsZUlkLCBwYW5lbEdyb3VwRWxlbWVudCk7XG4gIHJldHVybiBpbmRleCAhPSBudWxsID8gW2luZGV4LCBpbmRleCArIDFdIDogWy0xLCAtMV07XG59XG5cbmZ1bmN0aW9uIGdldFBhbmVsR3JvdXBFbGVtZW50KGlkLCByb290RWxlbWVudCA9IGRvY3VtZW50KSB7XG4gIHZhciBfZGF0YXNldDtcbiAgLy9JZiB0aGUgcm9vdCBlbGVtZW50IGlzIHRoZSBQYW5lbEdyb3VwXG4gIGlmIChyb290RWxlbWVudCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50ICYmIChyb290RWxlbWVudCA9PT0gbnVsbCB8fCByb290RWxlbWVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogKF9kYXRhc2V0ID0gcm9vdEVsZW1lbnQuZGF0YXNldCkgPT09IG51bGwgfHwgX2RhdGFzZXQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kYXRhc2V0LnBhbmVsR3JvdXBJZCkgPT0gaWQpIHtcbiAgICByZXR1cm4gcm9vdEVsZW1lbnQ7XG4gIH1cblxuICAvL0Vsc2UgcXVlcnkgY2hpbGRyZW5cbiAgY29uc3QgZWxlbWVudCA9IHJvb3RFbGVtZW50LnF1ZXJ5U2VsZWN0b3IoYFtkYXRhLXBhbmVsLWdyb3VwXVtkYXRhLXBhbmVsLWdyb3VwLWlkPVwiJHtpZH1cIl1gKTtcbiAgaWYgKGVsZW1lbnQpIHtcbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gZ2V0UmVzaXplSGFuZGxlRWxlbWVudChpZCwgc2NvcGUgPSBkb2N1bWVudCkge1xuICBjb25zdCBlbGVtZW50ID0gc2NvcGUucXVlcnlTZWxlY3RvcihgW2RhdGEtcGFuZWwtcmVzaXplLWhhbmRsZS1pZD1cIiR7aWR9XCJdYCk7XG4gIGlmIChlbGVtZW50KSB7XG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIGdldFJlc2l6ZUhhbmRsZVBhbmVsSWRzKGdyb3VwSWQsIGhhbmRsZUlkLCBwYW5lbHNBcnJheSwgc2NvcGUgPSBkb2N1bWVudCkge1xuICB2YXIgX3BhbmVsc0FycmF5JGluZGV4JGlkLCBfcGFuZWxzQXJyYXkkaW5kZXgsIF9wYW5lbHNBcnJheSRpZCwgX3BhbmVsc0FycmF5O1xuICBjb25zdCBoYW5kbGUgPSBnZXRSZXNpemVIYW5kbGVFbGVtZW50KGhhbmRsZUlkLCBzY29wZSk7XG4gIGNvbnN0IGhhbmRsZXMgPSBnZXRSZXNpemVIYW5kbGVFbGVtZW50c0Zvckdyb3VwKGdyb3VwSWQsIHNjb3BlKTtcbiAgY29uc3QgaW5kZXggPSBoYW5kbGUgPyBoYW5kbGVzLmluZGV4T2YoaGFuZGxlKSA6IC0xO1xuICBjb25zdCBpZEJlZm9yZSA9IChfcGFuZWxzQXJyYXkkaW5kZXgkaWQgPSAoX3BhbmVsc0FycmF5JGluZGV4ID0gcGFuZWxzQXJyYXlbaW5kZXhdKSA9PT0gbnVsbCB8fCBfcGFuZWxzQXJyYXkkaW5kZXggPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9wYW5lbHNBcnJheSRpbmRleC5pZCkgIT09IG51bGwgJiYgX3BhbmVsc0FycmF5JGluZGV4JGlkICE9PSB2b2lkIDAgPyBfcGFuZWxzQXJyYXkkaW5kZXgkaWQgOiBudWxsO1xuICBjb25zdCBpZEFmdGVyID0gKF9wYW5lbHNBcnJheSRpZCA9IChfcGFuZWxzQXJyYXkgPSBwYW5lbHNBcnJheVtpbmRleCArIDFdKSA9PT0gbnVsbCB8fCBfcGFuZWxzQXJyYXkgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9wYW5lbHNBcnJheS5pZCkgIT09IG51bGwgJiYgX3BhbmVsc0FycmF5JGlkICE9PSB2b2lkIDAgPyBfcGFuZWxzQXJyYXkkaWQgOiBudWxsO1xuICByZXR1cm4gW2lkQmVmb3JlLCBpZEFmdGVyXTtcbn1cblxuLy8gaHR0cHM6Ly93d3cudzMub3JnL1dBSS9BUklBL2FwZy9wYXR0ZXJucy93aW5kb3dzcGxpdHRlci9cblxuZnVuY3Rpb24gdXNlV2luZG93U3BsaXR0ZXJQYW5lbEdyb3VwQmVoYXZpb3Ioe1xuICBjb21taXR0ZWRWYWx1ZXNSZWYsXG4gIGVhZ2VyVmFsdWVzUmVmLFxuICBncm91cElkLFxuICBsYXlvdXQsXG4gIHBhbmVsRGF0YUFycmF5LFxuICBwYW5lbEdyb3VwRWxlbWVudCxcbiAgc2V0TGF5b3V0XG59KSB7XG4gIHVzZVJlZih7XG4gICAgZGlkV2FybkFib3V0TWlzc2luZ1Jlc2l6ZUhhbmRsZTogZmFsc2VcbiAgfSk7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFwYW5lbEdyb3VwRWxlbWVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBlYWdlclZhbHVlcyA9IGVhZ2VyVmFsdWVzUmVmLmN1cnJlbnQ7XG4gICAgYXNzZXJ0KGVhZ2VyVmFsdWVzLCBgRWFnZXIgdmFsdWVzIG5vdCBmb3VuZGApO1xuICAgIGNvbnN0IHtcbiAgICAgIHBhbmVsRGF0YUFycmF5XG4gICAgfSA9IGVhZ2VyVmFsdWVzO1xuICAgIGNvbnN0IGdyb3VwRWxlbWVudCA9IGdldFBhbmVsR3JvdXBFbGVtZW50KGdyb3VwSWQsIHBhbmVsR3JvdXBFbGVtZW50KTtcbiAgICBhc3NlcnQoZ3JvdXBFbGVtZW50ICE9IG51bGwsIGBObyBncm91cCBmb3VuZCBmb3IgaWQgXCIke2dyb3VwSWR9XCJgKTtcbiAgICBjb25zdCBoYW5kbGVzID0gZ2V0UmVzaXplSGFuZGxlRWxlbWVudHNGb3JHcm91cChncm91cElkLCBwYW5lbEdyb3VwRWxlbWVudCk7XG4gICAgYXNzZXJ0KGhhbmRsZXMsIGBObyByZXNpemUgaGFuZGxlcyBmb3VuZCBmb3IgZ3JvdXAgaWQgXCIke2dyb3VwSWR9XCJgKTtcbiAgICBjb25zdCBjbGVhbnVwRnVuY3Rpb25zID0gaGFuZGxlcy5tYXAoaGFuZGxlID0+IHtcbiAgICAgIGNvbnN0IGhhbmRsZUlkID0gaGFuZGxlLmdldEF0dHJpYnV0ZShcImRhdGEtcGFuZWwtcmVzaXplLWhhbmRsZS1pZFwiKTtcbiAgICAgIGFzc2VydChoYW5kbGVJZCwgYFJlc2l6ZSBoYW5kbGUgZWxlbWVudCBoYXMgbm8gaGFuZGxlIGlkIGF0dHJpYnV0ZWApO1xuICAgICAgY29uc3QgW2lkQmVmb3JlLCBpZEFmdGVyXSA9IGdldFJlc2l6ZUhhbmRsZVBhbmVsSWRzKGdyb3VwSWQsIGhhbmRsZUlkLCBwYW5lbERhdGFBcnJheSwgcGFuZWxHcm91cEVsZW1lbnQpO1xuICAgICAgaWYgKGlkQmVmb3JlID09IG51bGwgfHwgaWRBZnRlciA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiAoKSA9PiB7fTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG9uS2V5RG93biA9IGV2ZW50ID0+IHtcbiAgICAgICAgaWYgKGV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoIChldmVudC5rZXkpIHtcbiAgICAgICAgICBjYXNlIFwiRW50ZXJcIjpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgY29uc3QgaW5kZXggPSBwYW5lbERhdGFBcnJheS5maW5kSW5kZXgocGFuZWxEYXRhID0+IHBhbmVsRGF0YS5pZCA9PT0gaWRCZWZvcmUpO1xuICAgICAgICAgICAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhbmVsRGF0YSA9IHBhbmVsRGF0YUFycmF5W2luZGV4XTtcbiAgICAgICAgICAgICAgICBhc3NlcnQocGFuZWxEYXRhLCBgTm8gcGFuZWwgZGF0YSBmb3VuZCBmb3IgaW5kZXggJHtpbmRleH1gKTtcbiAgICAgICAgICAgICAgICBjb25zdCBzaXplID0gbGF5b3V0W2luZGV4XTtcbiAgICAgICAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICAgICAgICBjb2xsYXBzZWRTaXplID0gMCxcbiAgICAgICAgICAgICAgICAgIGNvbGxhcHNpYmxlLFxuICAgICAgICAgICAgICAgICAgbWluU2l6ZSA9IDBcbiAgICAgICAgICAgICAgICB9ID0gcGFuZWxEYXRhLmNvbnN0cmFpbnRzO1xuICAgICAgICAgICAgICAgIGlmIChzaXplICE9IG51bGwgJiYgY29sbGFwc2libGUpIHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IG5leHRMYXlvdXQgPSBhZGp1c3RMYXlvdXRCeURlbHRhKHtcbiAgICAgICAgICAgICAgICAgICAgZGVsdGE6IGZ1enp5TnVtYmVyc0VxdWFsKHNpemUsIGNvbGxhcHNlZFNpemUpID8gbWluU2l6ZSAtIGNvbGxhcHNlZFNpemUgOiBjb2xsYXBzZWRTaXplIC0gc2l6ZSxcbiAgICAgICAgICAgICAgICAgICAgaW5pdGlhbExheW91dDogbGF5b3V0LFxuICAgICAgICAgICAgICAgICAgICBwYW5lbENvbnN0cmFpbnRzOiBwYW5lbERhdGFBcnJheS5tYXAocGFuZWxEYXRhID0+IHBhbmVsRGF0YS5jb25zdHJhaW50cyksXG4gICAgICAgICAgICAgICAgICAgIHBpdm90SW5kaWNlczogZGV0ZXJtaW5lUGl2b3RJbmRpY2VzKGdyb3VwSWQsIGhhbmRsZUlkLCBwYW5lbEdyb3VwRWxlbWVudCksXG4gICAgICAgICAgICAgICAgICAgIHByZXZMYXlvdXQ6IGxheW91dCxcbiAgICAgICAgICAgICAgICAgICAgdHJpZ2dlcjogXCJrZXlib2FyZFwiXG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIGlmIChsYXlvdXQgIT09IG5leHRMYXlvdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0TGF5b3V0KG5leHRMYXlvdXQpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGhhbmRsZS5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCBvbktleURvd24pO1xuICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgaGFuZGxlLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIG9uS2V5RG93bik7XG4gICAgICB9O1xuICAgIH0pO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBjbGVhbnVwRnVuY3Rpb25zLmZvckVhY2goY2xlYW51cEZ1bmN0aW9uID0+IGNsZWFudXBGdW5jdGlvbigpKTtcbiAgICB9O1xuICB9LCBbcGFuZWxHcm91cEVsZW1lbnQsIGNvbW1pdHRlZFZhbHVlc1JlZiwgZWFnZXJWYWx1ZXNSZWYsIGdyb3VwSWQsIGxheW91dCwgcGFuZWxEYXRhQXJyYXksIHNldExheW91dF0pO1xufVxuXG5mdW5jdGlvbiBhcmVFcXVhbChhcnJheUEsIGFycmF5Qikge1xuICBpZiAoYXJyYXlBLmxlbmd0aCAhPT0gYXJyYXlCLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgYXJyYXlBLmxlbmd0aDsgaW5kZXgrKykge1xuICAgIGlmIChhcnJheUFbaW5kZXhdICE9PSBhcnJheUJbaW5kZXhdKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBnZXRSZXNpemVFdmVudEN1cnNvclBvc2l0aW9uKGRpcmVjdGlvbiwgZXZlbnQpIHtcbiAgY29uc3QgaXNIb3Jpem9udGFsID0gZGlyZWN0aW9uID09PSBcImhvcml6b250YWxcIjtcbiAgY29uc3Qge1xuICAgIHgsXG4gICAgeVxuICB9ID0gZ2V0UmVzaXplRXZlbnRDb29yZGluYXRlcyhldmVudCk7XG4gIHJldHVybiBpc0hvcml6b250YWwgPyB4IDogeTtcbn1cblxuZnVuY3Rpb24gY2FsY3VsYXRlRHJhZ09mZnNldFBlcmNlbnRhZ2UoZXZlbnQsIGRyYWdIYW5kbGVJZCwgZGlyZWN0aW9uLCBpbml0aWFsRHJhZ1N0YXRlLCBwYW5lbEdyb3VwRWxlbWVudCkge1xuICBjb25zdCBpc0hvcml6b250YWwgPSBkaXJlY3Rpb24gPT09IFwiaG9yaXpvbnRhbFwiO1xuICBjb25zdCBoYW5kbGVFbGVtZW50ID0gZ2V0UmVzaXplSGFuZGxlRWxlbWVudChkcmFnSGFuZGxlSWQsIHBhbmVsR3JvdXBFbGVtZW50KTtcbiAgYXNzZXJ0KGhhbmRsZUVsZW1lbnQsIGBObyByZXNpemUgaGFuZGxlIGVsZW1lbnQgZm91bmQgZm9yIGlkIFwiJHtkcmFnSGFuZGxlSWR9XCJgKTtcbiAgY29uc3QgZ3JvdXBJZCA9IGhhbmRsZUVsZW1lbnQuZ2V0QXR0cmlidXRlKFwiZGF0YS1wYW5lbC1ncm91cC1pZFwiKTtcbiAgYXNzZXJ0KGdyb3VwSWQsIGBSZXNpemUgaGFuZGxlIGVsZW1lbnQgaGFzIG5vIGdyb3VwIGlkIGF0dHJpYnV0ZWApO1xuICBsZXQge1xuICAgIGluaXRpYWxDdXJzb3JQb3NpdGlvblxuICB9ID0gaW5pdGlhbERyYWdTdGF0ZTtcbiAgY29uc3QgY3Vyc29yUG9zaXRpb24gPSBnZXRSZXNpemVFdmVudEN1cnNvclBvc2l0aW9uKGRpcmVjdGlvbiwgZXZlbnQpO1xuICBjb25zdCBncm91cEVsZW1lbnQgPSBnZXRQYW5lbEdyb3VwRWxlbWVudChncm91cElkLCBwYW5lbEdyb3VwRWxlbWVudCk7XG4gIGFzc2VydChncm91cEVsZW1lbnQsIGBObyBncm91cCBlbGVtZW50IGZvdW5kIGZvciBpZCBcIiR7Z3JvdXBJZH1cImApO1xuICBjb25zdCBncm91cFJlY3QgPSBncm91cEVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gIGNvbnN0IGdyb3VwU2l6ZUluUGl4ZWxzID0gaXNIb3Jpem9udGFsID8gZ3JvdXBSZWN0LndpZHRoIDogZ3JvdXBSZWN0LmhlaWdodDtcbiAgY29uc3Qgb2Zmc2V0UGl4ZWxzID0gY3Vyc29yUG9zaXRpb24gLSBpbml0aWFsQ3Vyc29yUG9zaXRpb247XG4gIGNvbnN0IG9mZnNldFBlcmNlbnRhZ2UgPSBvZmZzZXRQaXhlbHMgLyBncm91cFNpemVJblBpeGVscyAqIDEwMDtcbiAgcmV0dXJuIG9mZnNldFBlcmNlbnRhZ2U7XG59XG5cbi8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9Nb3VzZUV2ZW50L21vdmVtZW50WFxuZnVuY3Rpb24gY2FsY3VsYXRlRGVsdGFQZXJjZW50YWdlKGV2ZW50LCBkcmFnSGFuZGxlSWQsIGRpcmVjdGlvbiwgaW5pdGlhbERyYWdTdGF0ZSwga2V5Ym9hcmRSZXNpemVCeSwgcGFuZWxHcm91cEVsZW1lbnQpIHtcbiAgaWYgKGlzS2V5RG93bihldmVudCkpIHtcbiAgICBjb25zdCBpc0hvcml6b250YWwgPSBkaXJlY3Rpb24gPT09IFwiaG9yaXpvbnRhbFwiO1xuICAgIGxldCBkZWx0YSA9IDA7XG4gICAgaWYgKGV2ZW50LnNoaWZ0S2V5KSB7XG4gICAgICBkZWx0YSA9IDEwMDtcbiAgICB9IGVsc2UgaWYgKGtleWJvYXJkUmVzaXplQnkgIT0gbnVsbCkge1xuICAgICAgZGVsdGEgPSBrZXlib2FyZFJlc2l6ZUJ5O1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWx0YSA9IDEwO1xuICAgIH1cbiAgICBsZXQgbW92ZW1lbnQgPSAwO1xuICAgIHN3aXRjaCAoZXZlbnQua2V5KSB7XG4gICAgICBjYXNlIFwiQXJyb3dEb3duXCI6XG4gICAgICAgIG1vdmVtZW50ID0gaXNIb3Jpem9udGFsID8gMCA6IGRlbHRhO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJBcnJvd0xlZnRcIjpcbiAgICAgICAgbW92ZW1lbnQgPSBpc0hvcml6b250YWwgPyAtZGVsdGEgOiAwO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJBcnJvd1JpZ2h0XCI6XG4gICAgICAgIG1vdmVtZW50ID0gaXNIb3Jpem9udGFsID8gZGVsdGEgOiAwO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJBcnJvd1VwXCI6XG4gICAgICAgIG1vdmVtZW50ID0gaXNIb3Jpem9udGFsID8gMCA6IC1kZWx0YTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiRW5kXCI6XG4gICAgICAgIG1vdmVtZW50ID0gMTAwO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJIb21lXCI6XG4gICAgICAgIG1vdmVtZW50ID0gLTEwMDtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHJldHVybiBtb3ZlbWVudDtcbiAgfSBlbHNlIHtcbiAgICBpZiAoaW5pdGlhbERyYWdTdGF0ZSA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgcmV0dXJuIGNhbGN1bGF0ZURyYWdPZmZzZXRQZXJjZW50YWdlKGV2ZW50LCBkcmFnSGFuZGxlSWQsIGRpcmVjdGlvbiwgaW5pdGlhbERyYWdTdGF0ZSwgcGFuZWxHcm91cEVsZW1lbnQpO1xuICB9XG59XG5cbi8vIExheW91dCBzaG91bGQgYmUgcHJlLWNvbnZlcnRlZCBpbnRvIHBlcmNlbnRhZ2VzXG5mdW5jdGlvbiBjYWxsUGFuZWxDYWxsYmFja3MocGFuZWxzQXJyYXksIGxheW91dCwgcGFuZWxJZFRvTGFzdE5vdGlmaWVkU2l6ZU1hcCkge1xuICBsYXlvdXQuZm9yRWFjaCgoc2l6ZSwgaW5kZXgpID0+IHtcbiAgICBjb25zdCBwYW5lbERhdGEgPSBwYW5lbHNBcnJheVtpbmRleF07XG4gICAgYXNzZXJ0KHBhbmVsRGF0YSwgYFBhbmVsIGRhdGEgbm90IGZvdW5kIGZvciBpbmRleCAke2luZGV4fWApO1xuICAgIGNvbnN0IHtcbiAgICAgIGNhbGxiYWNrcyxcbiAgICAgIGNvbnN0cmFpbnRzLFxuICAgICAgaWQ6IHBhbmVsSWRcbiAgICB9ID0gcGFuZWxEYXRhO1xuICAgIGNvbnN0IHtcbiAgICAgIGNvbGxhcHNlZFNpemUgPSAwLFxuICAgICAgY29sbGFwc2libGVcbiAgICB9ID0gY29uc3RyYWludHM7XG4gICAgY29uc3QgbGFzdE5vdGlmaWVkU2l6ZSA9IHBhbmVsSWRUb0xhc3ROb3RpZmllZFNpemVNYXBbcGFuZWxJZF07XG4gICAgaWYgKGxhc3ROb3RpZmllZFNpemUgPT0gbnVsbCB8fCBzaXplICE9PSBsYXN0Tm90aWZpZWRTaXplKSB7XG4gICAgICBwYW5lbElkVG9MYXN0Tm90aWZpZWRTaXplTWFwW3BhbmVsSWRdID0gc2l6ZTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgb25Db2xsYXBzZSxcbiAgICAgICAgb25FeHBhbmQsXG4gICAgICAgIG9uUmVzaXplXG4gICAgICB9ID0gY2FsbGJhY2tzO1xuICAgICAgaWYgKG9uUmVzaXplKSB7XG4gICAgICAgIG9uUmVzaXplKHNpemUsIGxhc3ROb3RpZmllZFNpemUpO1xuICAgICAgfVxuICAgICAgaWYgKGNvbGxhcHNpYmxlICYmIChvbkNvbGxhcHNlIHx8IG9uRXhwYW5kKSkge1xuICAgICAgICBpZiAob25FeHBhbmQgJiYgKGxhc3ROb3RpZmllZFNpemUgPT0gbnVsbCB8fCBsYXN0Tm90aWZpZWRTaXplID09PSBjb2xsYXBzZWRTaXplKSAmJiBzaXplICE9PSBjb2xsYXBzZWRTaXplKSB7XG4gICAgICAgICAgb25FeHBhbmQoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob25Db2xsYXBzZSAmJiAobGFzdE5vdGlmaWVkU2l6ZSA9PSBudWxsIHx8IGxhc3ROb3RpZmllZFNpemUgIT09IGNvbGxhcHNlZFNpemUpICYmIHNpemUgPT09IGNvbGxhcHNlZFNpemUpIHtcbiAgICAgICAgICBvbkNvbGxhcHNlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBjb21wYXJlTGF5b3V0cyhhLCBiKSB7XG4gIGlmIChhLmxlbmd0aCAhPT0gYi5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gZWxzZSB7XG4gICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IGEubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICBpZiAoYVtpbmRleF0gIT0gYltpbmRleF0pIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuLy8gVGhpcyBtZXRob2QgcmV0dXJucyBhIG51bWJlciBiZXR3ZWVuIDEgYW5kIDEwMCByZXByZXNlbnRpbmdcblxuLy8gdGhlICUgb2YgdGhlIGdyb3VwJ3Mgb3ZlcmFsbCBzcGFjZSB0aGlzIHBhbmVsIHNob3VsZCBvY2N1cHkuXG5mdW5jdGlvbiBjb21wdXRlUGFuZWxGbGV4Qm94U3R5bGUoe1xuICBkZWZhdWx0U2l6ZSxcbiAgZHJhZ1N0YXRlLFxuICBsYXlvdXQsXG4gIHBhbmVsRGF0YSxcbiAgcGFuZWxJbmRleCxcbiAgcHJlY2lzaW9uID0gM1xufSkge1xuICBjb25zdCBzaXplID0gbGF5b3V0W3BhbmVsSW5kZXhdO1xuICBsZXQgZmxleEdyb3c7XG4gIGlmIChzaXplID09IG51bGwpIHtcbiAgICAvLyBJbml0aWFsIHJlbmRlciAoYmVmb3JlIHBhbmVscyBoYXZlIHJlZ2lzdGVyZWQgdGhlbXNlbHZlcylcbiAgICAvLyBJbiBvcmRlciB0byBzdXBwb3J0IHNlcnZlciByZW5kZXJpbmcsIGZhbGwgYmFjayB0byBkZWZhdWx0IHNpemUgaWYgcHJvdmlkZWRcbiAgICBmbGV4R3JvdyA9IGRlZmF1bHRTaXplICE9IHVuZGVmaW5lZCA/IGRlZmF1bHRTaXplLnRvUHJlY2lzaW9uKHByZWNpc2lvbikgOiBcIjFcIjtcbiAgfSBlbHNlIGlmIChwYW5lbERhdGEubGVuZ3RoID09PSAxKSB7XG4gICAgLy8gU3BlY2lhbCBjYXNlOiBTaW5nbGUgcGFuZWwgZ3JvdXAgc2hvdWxkIGFsd2F5cyBmaWxsIGZ1bGwgd2lkdGgvaGVpZ2h0XG4gICAgZmxleEdyb3cgPSBcIjFcIjtcbiAgfSBlbHNlIHtcbiAgICBmbGV4R3JvdyA9IHNpemUudG9QcmVjaXNpb24ocHJlY2lzaW9uKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIGZsZXhCYXNpczogMCxcbiAgICBmbGV4R3JvdyxcbiAgICBmbGV4U2hyaW5rOiAxLFxuICAgIC8vIFdpdGhvdXQgdGhpcywgUGFuZWwgc2l6ZXMgbWF5IGJlIHVuaW50ZW50aW9uYWxseSBvdmVycmlkZGVuIGJ5IHRoZWlyIGNvbnRlbnRcbiAgICBvdmVyZmxvdzogXCJoaWRkZW5cIixcbiAgICAvLyBEaXNhYmxlIHBvaW50ZXIgZXZlbnRzIGluc2lkZSBvZiBhIHBhbmVsIGR1cmluZyByZXNpemVcbiAgICAvLyBUaGlzIGF2b2lkIGVkZ2UgY2FzZXMgbGlrZSBuZXN0ZWQgaWZyYW1lc1xuICAgIHBvaW50ZXJFdmVudHM6IGRyYWdTdGF0ZSAhPT0gbnVsbCA/IFwibm9uZVwiIDogdW5kZWZpbmVkXG4gIH07XG59XG5cbmZ1bmN0aW9uIGRlYm91bmNlKGNhbGxiYWNrLCBkdXJhdGlvbk1zID0gMTApIHtcbiAgbGV0IHRpbWVvdXRJZCA9IG51bGw7XG4gIGxldCBjYWxsYWJsZSA9ICguLi5hcmdzKSA9PiB7XG4gICAgaWYgKHRpbWVvdXRJZCAhPT0gbnVsbCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG4gICAgfVxuICAgIHRpbWVvdXRJZCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgY2FsbGJhY2soLi4uYXJncyk7XG4gICAgfSwgZHVyYXRpb25Ncyk7XG4gIH07XG4gIHJldHVybiBjYWxsYWJsZTtcbn1cblxuLy8gUGFuZWxHcm91cCBtaWdodCBiZSByZW5kZXJpbmcgaW4gYSBzZXJ2ZXItc2lkZSBlbnZpcm9ubWVudCB3aGVyZSBsb2NhbFN0b3JhZ2UgaXMgbm90IGF2YWlsYWJsZVxuLy8gb3Igb24gYSBicm93c2VyIHdpdGggY29va2llcy9zdG9yYWdlIGRpc2FibGVkLlxuLy8gSW4gZWl0aGVyIGNhc2UsIHRoaXMgZnVuY3Rpb24gYXZvaWRzIGFjY2Vzc2luZyBsb2NhbFN0b3JhZ2UgdW50aWwgbmVlZGVkLFxuLy8gYW5kIGF2b2lkcyB0aHJvd2luZyB1c2VyLXZpc2libGUgZXJyb3JzLlxuZnVuY3Rpb24gaW5pdGlhbGl6ZURlZmF1bHRTdG9yYWdlKHN0b3JhZ2VPYmplY3QpIHtcbiAgdHJ5IHtcbiAgICBpZiAodHlwZW9mIGxvY2FsU3RvcmFnZSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgLy8gQnlwYXNzIHRoaXMgY2hlY2sgZm9yIGZ1dHVyZSBjYWxsc1xuICAgICAgc3RvcmFnZU9iamVjdC5nZXRJdGVtID0gbmFtZSA9PiB7XG4gICAgICAgIHJldHVybiBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShuYW1lKTtcbiAgICAgIH07XG4gICAgICBzdG9yYWdlT2JqZWN0LnNldEl0ZW0gPSAobmFtZSwgdmFsdWUpID0+IHtcbiAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0obmFtZSwgdmFsdWUpO1xuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwibG9jYWxTdG9yYWdlIG5vdCBzdXBwb3J0ZWQgaW4gdGhpcyBlbnZpcm9ubWVudFwiKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcihlcnJvcik7XG4gICAgc3RvcmFnZU9iamVjdC5nZXRJdGVtID0gKCkgPT4gbnVsbDtcbiAgICBzdG9yYWdlT2JqZWN0LnNldEl0ZW0gPSAoKSA9PiB7fTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRQYW5lbEdyb3VwS2V5KGF1dG9TYXZlSWQpIHtcbiAgcmV0dXJuIGByZWFjdC1yZXNpemFibGUtcGFuZWxzOiR7YXV0b1NhdmVJZH1gO1xufVxuXG4vLyBOb3RlIHRoYXQgUGFuZWwgaWRzIG1pZ2h0IGJlIHVzZXItcHJvdmlkZWQgKHN0YWJsZSkgb3IgdXNlSWQgZ2VuZXJhdGVkIChub24tZGV0ZXJtaW5pc3RpYylcbi8vIHNvIHRoZXkgc2hvdWxkIG5vdCBiZSB1c2VkIGFzIHBhcnQgb2YgdGhlIHNlcmlhbGl6YXRpb24ga2V5LlxuLy8gVXNpbmcgdGhlIG1pbi9tYXggc2l6ZSBhdHRyaWJ1dGVzIHNob3VsZCB3b3JrIHdlbGwgZW5vdWdoIGFzIGEgYmFja3VwLlxuLy8gUHJlLXNvcnRpbmcgYnkgbWluU2l6ZSBhbGxvd3MgcmVtZW1iZXJpbmcgbGF5b3V0cyBldmVuIGlmIHBhbmVscyBhcmUgcmUtb3JkZXJlZC9kcmFnZ2VkLlxuZnVuY3Rpb24gZ2V0UGFuZWxLZXkocGFuZWxzKSB7XG4gIHJldHVybiBwYW5lbHMubWFwKHBhbmVsID0+IHtcbiAgICBjb25zdCB7XG4gICAgICBjb25zdHJhaW50cyxcbiAgICAgIGlkLFxuICAgICAgaWRJc0Zyb21Qcm9wcyxcbiAgICAgIG9yZGVyXG4gICAgfSA9IHBhbmVsO1xuICAgIGlmIChpZElzRnJvbVByb3BzKSB7XG4gICAgICByZXR1cm4gaWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBvcmRlciA/IGAke29yZGVyfToke0pTT04uc3RyaW5naWZ5KGNvbnN0cmFpbnRzKX1gIDogSlNPTi5zdHJpbmdpZnkoY29uc3RyYWludHMpO1xuICAgIH1cbiAgfSkuc29ydCgoYSwgYikgPT4gYS5sb2NhbGVDb21wYXJlKGIpKS5qb2luKFwiLFwiKTtcbn1cbmZ1bmN0aW9uIGxvYWRTZXJpYWxpemVkUGFuZWxHcm91cFN0YXRlKGF1dG9TYXZlSWQsIHN0b3JhZ2UpIHtcbiAgdHJ5IHtcbiAgICBjb25zdCBwYW5lbEdyb3VwS2V5ID0gZ2V0UGFuZWxHcm91cEtleShhdXRvU2F2ZUlkKTtcbiAgICBjb25zdCBzZXJpYWxpemVkID0gc3RvcmFnZS5nZXRJdGVtKHBhbmVsR3JvdXBLZXkpO1xuICAgIGlmIChzZXJpYWxpemVkKSB7XG4gICAgICBjb25zdCBwYXJzZWQgPSBKU09OLnBhcnNlKHNlcmlhbGl6ZWQpO1xuICAgICAgaWYgKHR5cGVvZiBwYXJzZWQgPT09IFwib2JqZWN0XCIgJiYgcGFyc2VkICE9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlZDtcbiAgICAgIH1cbiAgICB9XG4gIH0gY2F0Y2ggKGVycm9yKSB7fVxuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIHNhdmVQYW5lbEdyb3VwU3RhdGUoYXV0b1NhdmVJZCwgcGFuZWxzLCBwYW5lbFNpemVzQmVmb3JlQ29sbGFwc2UsIHNpemVzLCBzdG9yYWdlKSB7XG4gIHZhciBfbG9hZFNlcmlhbGl6ZWRQYW5lbEcyO1xuICBjb25zdCBwYW5lbEdyb3VwS2V5ID0gZ2V0UGFuZWxHcm91cEtleShhdXRvU2F2ZUlkKTtcbiAgY29uc3QgcGFuZWxLZXkgPSBnZXRQYW5lbEtleShwYW5lbHMpO1xuICBjb25zdCBzdGF0ZSA9IChfbG9hZFNlcmlhbGl6ZWRQYW5lbEcyID0gbG9hZFNlcmlhbGl6ZWRQYW5lbEdyb3VwU3RhdGUoYXV0b1NhdmVJZCwgc3RvcmFnZSkpICE9PSBudWxsICYmIF9sb2FkU2VyaWFsaXplZFBhbmVsRzIgIT09IHZvaWQgMCA/IF9sb2FkU2VyaWFsaXplZFBhbmVsRzIgOiB7fTtcbiAgc3RhdGVbcGFuZWxLZXldID0ge1xuICAgIGV4cGFuZFRvU2l6ZXM6IE9iamVjdC5mcm9tRW50cmllcyhwYW5lbFNpemVzQmVmb3JlQ29sbGFwc2UuZW50cmllcygpKSxcbiAgICBsYXlvdXQ6IHNpemVzXG4gIH07XG4gIHRyeSB7XG4gICAgc3RvcmFnZS5zZXRJdGVtKHBhbmVsR3JvdXBLZXksIEpTT04uc3RyaW5naWZ5KHN0YXRlKSk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcihlcnJvcik7XG4gIH1cbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVQYW5lbENvbnN0cmFpbnRzKHtcbiAgcGFuZWxDb25zdHJhaW50czogcGFuZWxDb25zdHJhaW50c0FycmF5LFxuICBwYW5lbElkLFxuICBwYW5lbEluZGV4XG59KSB7XG4gIHtcbiAgICBjb25zdCB3YXJuaW5ncyA9IFtdO1xuICAgIGNvbnN0IHBhbmVsQ29uc3RyYWludHMgPSBwYW5lbENvbnN0cmFpbnRzQXJyYXlbcGFuZWxJbmRleF07XG4gICAgYXNzZXJ0KHBhbmVsQ29uc3RyYWludHMsIGBObyBwYW5lbCBjb25zdHJhaW50cyBmb3VuZCBmb3IgaW5kZXggJHtwYW5lbEluZGV4fWApO1xuICAgIGNvbnN0IHtcbiAgICAgIGNvbGxhcHNlZFNpemUgPSAwLFxuICAgICAgY29sbGFwc2libGUgPSBmYWxzZSxcbiAgICAgIGRlZmF1bHRTaXplLFxuICAgICAgbWF4U2l6ZSA9IDEwMCxcbiAgICAgIG1pblNpemUgPSAwXG4gICAgfSA9IHBhbmVsQ29uc3RyYWludHM7XG4gICAgaWYgKG1pblNpemUgPiBtYXhTaXplKSB7XG4gICAgICB3YXJuaW5ncy5wdXNoKGBtaW4gc2l6ZSAoJHttaW5TaXplfSUpIHNob3VsZCBub3QgYmUgZ3JlYXRlciB0aGFuIG1heCBzaXplICgke21heFNpemV9JSlgKTtcbiAgICB9XG4gICAgaWYgKGRlZmF1bHRTaXplICE9IG51bGwpIHtcbiAgICAgIGlmIChkZWZhdWx0U2l6ZSA8IDApIHtcbiAgICAgICAgd2FybmluZ3MucHVzaChcImRlZmF1bHQgc2l6ZSBzaG91bGQgbm90IGJlIGxlc3MgdGhhbiAwXCIpO1xuICAgICAgfSBlbHNlIGlmIChkZWZhdWx0U2l6ZSA8IG1pblNpemUgJiYgKCFjb2xsYXBzaWJsZSB8fCBkZWZhdWx0U2l6ZSAhPT0gY29sbGFwc2VkU2l6ZSkpIHtcbiAgICAgICAgd2FybmluZ3MucHVzaChcImRlZmF1bHQgc2l6ZSBzaG91bGQgbm90IGJlIGxlc3MgdGhhbiBtaW4gc2l6ZVwiKTtcbiAgICAgIH1cbiAgICAgIGlmIChkZWZhdWx0U2l6ZSA+IDEwMCkge1xuICAgICAgICB3YXJuaW5ncy5wdXNoKFwiZGVmYXVsdCBzaXplIHNob3VsZCBub3QgYmUgZ3JlYXRlciB0aGFuIDEwMFwiKTtcbiAgICAgIH0gZWxzZSBpZiAoZGVmYXVsdFNpemUgPiBtYXhTaXplKSB7XG4gICAgICAgIHdhcm5pbmdzLnB1c2goXCJkZWZhdWx0IHNpemUgc2hvdWxkIG5vdCBiZSBncmVhdGVyIHRoYW4gbWF4IHNpemVcIik7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChjb2xsYXBzZWRTaXplID4gbWluU2l6ZSkge1xuICAgICAgd2FybmluZ3MucHVzaChcImNvbGxhcHNlZCBzaXplIHNob3VsZCBub3QgYmUgZ3JlYXRlciB0aGFuIG1pbiBzaXplXCIpO1xuICAgIH1cbiAgICBpZiAod2FybmluZ3MubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgbmFtZSA9IHBhbmVsSWQgIT0gbnVsbCA/IGBQYW5lbCBcIiR7cGFuZWxJZH1cImAgOiBcIlBhbmVsXCI7XG4gICAgICBjb25zb2xlLndhcm4oYCR7bmFtZX0gaGFzIGFuIGludmFsaWQgY29uZmlndXJhdGlvbjpcXG5cXG4ke3dhcm5pbmdzLmpvaW4oXCJcXG5cIil9YCk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG4vLyBBbGwgdW5pdHMgbXVzdCBiZSBpbiBwZXJjZW50YWdlczsgcGl4ZWwgdmFsdWVzIHNob3VsZCBiZSBwcmUtY29udmVydGVkXG5mdW5jdGlvbiB2YWxpZGF0ZVBhbmVsR3JvdXBMYXlvdXQoe1xuICBsYXlvdXQ6IHByZXZMYXlvdXQsXG4gIHBhbmVsQ29uc3RyYWludHNcbn0pIHtcbiAgY29uc3QgbmV4dExheW91dCA9IFsuLi5wcmV2TGF5b3V0XTtcbiAgY29uc3QgbmV4dExheW91dFRvdGFsU2l6ZSA9IG5leHRMYXlvdXQucmVkdWNlKChhY2N1bXVsYXRlZCwgY3VycmVudCkgPT4gYWNjdW11bGF0ZWQgKyBjdXJyZW50LCAwKTtcblxuICAvLyBWYWxpZGF0ZSBsYXlvdXQgZXhwZWN0YXRpb25zXG4gIGlmIChuZXh0TGF5b3V0Lmxlbmd0aCAhPT0gcGFuZWxDb25zdHJhaW50cy5sZW5ndGgpIHtcbiAgICB0aHJvdyBFcnJvcihgSW52YWxpZCAke3BhbmVsQ29uc3RyYWludHMubGVuZ3RofSBwYW5lbCBsYXlvdXQ6ICR7bmV4dExheW91dC5tYXAoc2l6ZSA9PiBgJHtzaXplfSVgKS5qb2luKFwiLCBcIil9YCk7XG4gIH0gZWxzZSBpZiAoIWZ1enp5TnVtYmVyc0VxdWFsKG5leHRMYXlvdXRUb3RhbFNpemUsIDEwMCkpIHtcbiAgICAvLyBUaGlzIGlzIG5vdCBpZGVhbCBzbyB3ZSBzaG91bGQgd2FybiBhYm91dCBpdCwgYnV0IGl0IG1heSBiZSByZWNvdmVyYWJsZSBpbiBzb21lIGNhc2VzXG4gICAgLy8gKGVzcGVjaWFsbHkgaWYgdGhlIGFtb3VudCBpcyBzbWFsbClcbiAgICB7XG4gICAgICBjb25zb2xlLndhcm4oYFdBUk5JTkc6IEludmFsaWQgbGF5b3V0IHRvdGFsIHNpemU6ICR7bmV4dExheW91dC5tYXAoc2l6ZSA9PiBgJHtzaXplfSVgKS5qb2luKFwiLCBcIil9LiBMYXlvdXQgbm9ybWFsaXphdGlvbiB3aWxsIGJlIGFwcGxpZWQuYCk7XG4gICAgfVxuICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBwYW5lbENvbnN0cmFpbnRzLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgY29uc3QgdW5zYWZlU2l6ZSA9IG5leHRMYXlvdXRbaW5kZXhdO1xuICAgICAgYXNzZXJ0KHVuc2FmZVNpemUgIT0gbnVsbCwgYE5vIGxheW91dCBkYXRhIGZvdW5kIGZvciBpbmRleCAke2luZGV4fWApO1xuICAgICAgY29uc3Qgc2FmZVNpemUgPSAxMDAgLyBuZXh0TGF5b3V0VG90YWxTaXplICogdW5zYWZlU2l6ZTtcbiAgICAgIG5leHRMYXlvdXRbaW5kZXhdID0gc2FmZVNpemU7XG4gICAgfVxuICB9XG4gIGxldCByZW1haW5pbmdTaXplID0gMDtcblxuICAvLyBGaXJzdCBwYXNzOiBWYWxpZGF0ZSB0aGUgcHJvcG9zZWQgbGF5b3V0IGdpdmVuIGVhY2ggcGFuZWwncyBjb25zdHJhaW50c1xuICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgcGFuZWxDb25zdHJhaW50cy5sZW5ndGg7IGluZGV4KyspIHtcbiAgICBjb25zdCB1bnNhZmVTaXplID0gbmV4dExheW91dFtpbmRleF07XG4gICAgYXNzZXJ0KHVuc2FmZVNpemUgIT0gbnVsbCwgYE5vIGxheW91dCBkYXRhIGZvdW5kIGZvciBpbmRleCAke2luZGV4fWApO1xuICAgIGNvbnN0IHNhZmVTaXplID0gcmVzaXplUGFuZWwoe1xuICAgICAgcGFuZWxDb25zdHJhaW50cyxcbiAgICAgIHBhbmVsSW5kZXg6IGluZGV4LFxuICAgICAgc2l6ZTogdW5zYWZlU2l6ZVxuICAgIH0pO1xuICAgIGlmICh1bnNhZmVTaXplICE9IHNhZmVTaXplKSB7XG4gICAgICByZW1haW5pbmdTaXplICs9IHVuc2FmZVNpemUgLSBzYWZlU2l6ZTtcbiAgICAgIG5leHRMYXlvdXRbaW5kZXhdID0gc2FmZVNpemU7XG4gICAgfVxuICB9XG5cbiAgLy8gSWYgdGhlcmUgaXMgYWRkaXRpb25hbCwgbGVmdCBvdmVyIHNwYWNlLCBhc3NpZ24gaXQgdG8gYW55IHBhbmVsKHMpIHRoYXQgcGVybWl0cyBpdFxuICAvLyAoSXQncyBub3Qgd29ydGggdGFraW5nIG11bHRpcGxlIGFkZGl0aW9uYWwgcGFzc2VzIHRvIGV2ZW5seSBkaXN0cmlidXRlKVxuICBpZiAoIWZ1enp5TnVtYmVyc0VxdWFsKHJlbWFpbmluZ1NpemUsIDApKSB7XG4gICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IHBhbmVsQ29uc3RyYWludHMubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICBjb25zdCBwcmV2U2l6ZSA9IG5leHRMYXlvdXRbaW5kZXhdO1xuICAgICAgYXNzZXJ0KHByZXZTaXplICE9IG51bGwsIGBObyBsYXlvdXQgZGF0YSBmb3VuZCBmb3IgaW5kZXggJHtpbmRleH1gKTtcbiAgICAgIGNvbnN0IHVuc2FmZVNpemUgPSBwcmV2U2l6ZSArIHJlbWFpbmluZ1NpemU7XG4gICAgICBjb25zdCBzYWZlU2l6ZSA9IHJlc2l6ZVBhbmVsKHtcbiAgICAgICAgcGFuZWxDb25zdHJhaW50cyxcbiAgICAgICAgcGFuZWxJbmRleDogaW5kZXgsXG4gICAgICAgIHNpemU6IHVuc2FmZVNpemVcbiAgICAgIH0pO1xuICAgICAgaWYgKHByZXZTaXplICE9PSBzYWZlU2l6ZSkge1xuICAgICAgICByZW1haW5pbmdTaXplIC09IHNhZmVTaXplIC0gcHJldlNpemU7XG4gICAgICAgIG5leHRMYXlvdXRbaW5kZXhdID0gc2FmZVNpemU7XG5cbiAgICAgICAgLy8gT25jZSB3ZSd2ZSB1c2VkIHVwIHRoZSByZW1haW5kZXIsIGJhaWxcbiAgICAgICAgaWYgKGZ1enp5TnVtYmVyc0VxdWFsKHJlbWFpbmluZ1NpemUsIDApKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5leHRMYXlvdXQ7XG59XG5cbmNvbnN0IExPQ0FMX1NUT1JBR0VfREVCT1VOQ0VfSU5URVJWQUwgPSAxMDA7XG5jb25zdCBkZWZhdWx0U3RvcmFnZSA9IHtcbiAgZ2V0SXRlbTogbmFtZSA9PiB7XG4gICAgaW5pdGlhbGl6ZURlZmF1bHRTdG9yYWdlKGRlZmF1bHRTdG9yYWdlKTtcbiAgICByZXR1cm4gZGVmYXVsdFN0b3JhZ2UuZ2V0SXRlbShuYW1lKTtcbiAgfSxcbiAgc2V0SXRlbTogKG5hbWUsIHZhbHVlKSA9PiB7XG4gICAgaW5pdGlhbGl6ZURlZmF1bHRTdG9yYWdlKGRlZmF1bHRTdG9yYWdlKTtcbiAgICBkZWZhdWx0U3RvcmFnZS5zZXRJdGVtKG5hbWUsIHZhbHVlKTtcbiAgfVxufTtcbmNvbnN0IGRlYm91bmNlTWFwID0ge307XG5mdW5jdGlvbiBQYW5lbEdyb3VwV2l0aEZvcndhcmRlZFJlZih7XG4gIGF1dG9TYXZlSWQgPSBudWxsLFxuICBjaGlsZHJlbixcbiAgY2xhc3NOYW1lOiBjbGFzc05hbWVGcm9tUHJvcHMgPSBcIlwiLFxuICBkaXJlY3Rpb24sXG4gIGZvcndhcmRlZFJlZixcbiAgaWQ6IGlkRnJvbVByb3BzID0gbnVsbCxcbiAgb25MYXlvdXQgPSBudWxsLFxuICBrZXlib2FyZFJlc2l6ZUJ5ID0gbnVsbCxcbiAgc3RvcmFnZSA9IGRlZmF1bHRTdG9yYWdlLFxuICBzdHlsZTogc3R5bGVGcm9tUHJvcHMsXG4gIHRhZ05hbWU6IFR5cGUgPSBcImRpdlwiLFxuICAuLi5yZXN0XG59KSB7XG4gIGNvbnN0IGdyb3VwSWQgPSB1c2VVbmlxdWVJZChpZEZyb21Qcm9wcyk7XG4gIGNvbnN0IHBhbmVsR3JvdXBFbGVtZW50UmVmID0gdXNlUmVmKG51bGwpO1xuICBjb25zdCBbZHJhZ1N0YXRlLCBzZXREcmFnU3RhdGVdID0gdXNlU3RhdGUobnVsbCk7XG4gIGNvbnN0IFtsYXlvdXQsIHNldExheW91dF0gPSB1c2VTdGF0ZShbXSk7XG4gIGNvbnN0IHBhbmVsSWRUb0xhc3ROb3RpZmllZFNpemVNYXBSZWYgPSB1c2VSZWYoe30pO1xuICBjb25zdCBwYW5lbFNpemVCZWZvcmVDb2xsYXBzZVJlZiA9IHVzZVJlZihuZXcgTWFwKCkpO1xuICBjb25zdCBwcmV2RGVsdGFSZWYgPSB1c2VSZWYoMCk7XG4gIGNvbnN0IGNvbW1pdHRlZFZhbHVlc1JlZiA9IHVzZVJlZih7XG4gICAgYXV0b1NhdmVJZCxcbiAgICBkaXJlY3Rpb24sXG4gICAgZHJhZ1N0YXRlLFxuICAgIGlkOiBncm91cElkLFxuICAgIGtleWJvYXJkUmVzaXplQnksXG4gICAgb25MYXlvdXQsXG4gICAgc3RvcmFnZVxuICB9KTtcbiAgY29uc3QgZWFnZXJWYWx1ZXNSZWYgPSB1c2VSZWYoe1xuICAgIGxheW91dCxcbiAgICBwYW5lbERhdGFBcnJheTogW10sXG4gICAgcGFuZWxEYXRhQXJyYXlDaGFuZ2VkOiBmYWxzZVxuICB9KTtcbiAgY29uc3QgZGV2V2FybmluZ3NSZWYgPSB1c2VSZWYoe1xuICAgIGRpZExvZ0lkQW5kT3JkZXJXYXJuaW5nOiBmYWxzZSxcbiAgICBkaWRMb2dQYW5lbENvbnN0cmFpbnRzV2FybmluZzogZmFsc2UsXG4gICAgcHJldlBhbmVsSWRzOiBbXVxuICB9KTtcbiAgdXNlSW1wZXJhdGl2ZUhhbmRsZShmb3J3YXJkZWRSZWYsICgpID0+ICh7XG4gICAgZ2V0SWQ6ICgpID0+IGNvbW1pdHRlZFZhbHVlc1JlZi5jdXJyZW50LmlkLFxuICAgIGdldExheW91dDogKCkgPT4ge1xuICAgICAgY29uc3Qge1xuICAgICAgICBsYXlvdXRcbiAgICAgIH0gPSBlYWdlclZhbHVlc1JlZi5jdXJyZW50O1xuICAgICAgcmV0dXJuIGxheW91dDtcbiAgICB9LFxuICAgIHNldExheW91dDogdW5zYWZlTGF5b3V0ID0+IHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgb25MYXlvdXRcbiAgICAgIH0gPSBjb21taXR0ZWRWYWx1ZXNSZWYuY3VycmVudDtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgbGF5b3V0OiBwcmV2TGF5b3V0LFxuICAgICAgICBwYW5lbERhdGFBcnJheVxuICAgICAgfSA9IGVhZ2VyVmFsdWVzUmVmLmN1cnJlbnQ7XG4gICAgICBjb25zdCBzYWZlTGF5b3V0ID0gdmFsaWRhdGVQYW5lbEdyb3VwTGF5b3V0KHtcbiAgICAgICAgbGF5b3V0OiB1bnNhZmVMYXlvdXQsXG4gICAgICAgIHBhbmVsQ29uc3RyYWludHM6IHBhbmVsRGF0YUFycmF5Lm1hcChwYW5lbERhdGEgPT4gcGFuZWxEYXRhLmNvbnN0cmFpbnRzKVxuICAgICAgfSk7XG4gICAgICBpZiAoIWFyZUVxdWFsKHByZXZMYXlvdXQsIHNhZmVMYXlvdXQpKSB7XG4gICAgICAgIHNldExheW91dChzYWZlTGF5b3V0KTtcbiAgICAgICAgZWFnZXJWYWx1ZXNSZWYuY3VycmVudC5sYXlvdXQgPSBzYWZlTGF5b3V0O1xuICAgICAgICBpZiAob25MYXlvdXQpIHtcbiAgICAgICAgICBvbkxheW91dChzYWZlTGF5b3V0KTtcbiAgICAgICAgfVxuICAgICAgICBjYWxsUGFuZWxDYWxsYmFja3MocGFuZWxEYXRhQXJyYXksIHNhZmVMYXlvdXQsIHBhbmVsSWRUb0xhc3ROb3RpZmllZFNpemVNYXBSZWYuY3VycmVudCk7XG4gICAgICB9XG4gICAgfVxuICB9KSwgW10pO1xuICB1c2VXaW5kb3dTcGxpdHRlclBhbmVsR3JvdXBCZWhhdmlvcih7XG4gICAgY29tbWl0dGVkVmFsdWVzUmVmLFxuICAgIGVhZ2VyVmFsdWVzUmVmLFxuICAgIGdyb3VwSWQsXG4gICAgbGF5b3V0LFxuICAgIHBhbmVsRGF0YUFycmF5OiBlYWdlclZhbHVlc1JlZi5jdXJyZW50LnBhbmVsRGF0YUFycmF5LFxuICAgIHNldExheW91dCxcbiAgICBwYW5lbEdyb3VwRWxlbWVudDogcGFuZWxHcm91cEVsZW1lbnRSZWYuY3VycmVudFxuICB9KTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCB7XG4gICAgICBwYW5lbERhdGFBcnJheVxuICAgIH0gPSBlYWdlclZhbHVlc1JlZi5jdXJyZW50O1xuXG4gICAgLy8gSWYgdGhpcyBwYW5lbCBoYXMgYmVlbiBjb25maWd1cmVkIHRvIHBlcnNpc3Qgc2l6aW5nIGluZm9ybWF0aW9uLCBzYXZlIHNpemVzIHRvIGxvY2FsIHN0b3JhZ2UuXG4gICAgaWYgKGF1dG9TYXZlSWQpIHtcbiAgICAgIGlmIChsYXlvdXQubGVuZ3RoID09PSAwIHx8IGxheW91dC5sZW5ndGggIT09IHBhbmVsRGF0YUFycmF5Lmxlbmd0aCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBsZXQgZGVib3VuY2VkU2F2ZSA9IGRlYm91bmNlTWFwW2F1dG9TYXZlSWRdO1xuXG4gICAgICAvLyBMaW1pdCB0aGUgZnJlcXVlbmN5IG9mIGxvY2FsU3RvcmFnZSB1cGRhdGVzLlxuICAgICAgaWYgKGRlYm91bmNlZFNhdmUgPT0gbnVsbCkge1xuICAgICAgICBkZWJvdW5jZWRTYXZlID0gZGVib3VuY2Uoc2F2ZVBhbmVsR3JvdXBTdGF0ZSwgTE9DQUxfU1RPUkFHRV9ERUJPVU5DRV9JTlRFUlZBTCk7XG4gICAgICAgIGRlYm91bmNlTWFwW2F1dG9TYXZlSWRdID0gZGVib3VuY2VkU2F2ZTtcbiAgICAgIH1cblxuICAgICAgLy8gQ2xvbmUgbXV0YWJsZSBkYXRhIGJlZm9yZSBwYXNzaW5nIHRvIHRoZSBkZWJvdW5jZWQgZnVuY3Rpb24sXG4gICAgICAvLyBlbHNlIHdlIHJ1biB0aGUgcmlzayBvZiBzYXZpbmcgYW4gaW5jb3JyZWN0IGNvbWJpbmF0aW9uIG9mIG11dGFibGUgYW5kIGltbXV0YWJsZSB2YWx1ZXMgdG8gc3RhdGUuXG4gICAgICBjb25zdCBjbG9uZWRQYW5lbERhdGFBcnJheSA9IFsuLi5wYW5lbERhdGFBcnJheV07XG4gICAgICBjb25zdCBjbG9uZWRQYW5lbFNpemVzQmVmb3JlQ29sbGFwc2UgPSBuZXcgTWFwKHBhbmVsU2l6ZUJlZm9yZUNvbGxhcHNlUmVmLmN1cnJlbnQpO1xuICAgICAgZGVib3VuY2VkU2F2ZShhdXRvU2F2ZUlkLCBjbG9uZWRQYW5lbERhdGFBcnJheSwgY2xvbmVkUGFuZWxTaXplc0JlZm9yZUNvbGxhcHNlLCBsYXlvdXQsIHN0b3JhZ2UpO1xuICAgIH1cbiAgfSwgW2F1dG9TYXZlSWQsIGxheW91dCwgc3RvcmFnZV0pO1xuXG4gIC8vIERFViB3YXJuaW5nc1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgcGFuZWxEYXRhQXJyYXlcbiAgICAgIH0gPSBlYWdlclZhbHVlc1JlZi5jdXJyZW50O1xuICAgICAgY29uc3Qge1xuICAgICAgICBkaWRMb2dJZEFuZE9yZGVyV2FybmluZyxcbiAgICAgICAgZGlkTG9nUGFuZWxDb25zdHJhaW50c1dhcm5pbmcsXG4gICAgICAgIHByZXZQYW5lbElkc1xuICAgICAgfSA9IGRldldhcm5pbmdzUmVmLmN1cnJlbnQ7XG4gICAgICBpZiAoIWRpZExvZ0lkQW5kT3JkZXJXYXJuaW5nKSB7XG4gICAgICAgIGNvbnN0IHBhbmVsSWRzID0gcGFuZWxEYXRhQXJyYXkubWFwKCh7XG4gICAgICAgICAgaWRcbiAgICAgICAgfSkgPT4gaWQpO1xuICAgICAgICBkZXZXYXJuaW5nc1JlZi5jdXJyZW50LnByZXZQYW5lbElkcyA9IHBhbmVsSWRzO1xuICAgICAgICBjb25zdCBwYW5lbHNIYXZlQ2hhbmdlZCA9IHByZXZQYW5lbElkcy5sZW5ndGggPiAwICYmICFhcmVFcXVhbChwcmV2UGFuZWxJZHMsIHBhbmVsSWRzKTtcbiAgICAgICAgaWYgKHBhbmVsc0hhdmVDaGFuZ2VkKSB7XG4gICAgICAgICAgaWYgKHBhbmVsRGF0YUFycmF5LmZpbmQoKHtcbiAgICAgICAgICAgIGlkSXNGcm9tUHJvcHMsXG4gICAgICAgICAgICBvcmRlclxuICAgICAgICAgIH0pID0+ICFpZElzRnJvbVByb3BzIHx8IG9yZGVyID09IG51bGwpKSB7XG4gICAgICAgICAgICBkZXZXYXJuaW5nc1JlZi5jdXJyZW50LmRpZExvZ0lkQW5kT3JkZXJXYXJuaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihgV0FSTklORzogUGFuZWwgaWQgYW5kIG9yZGVyIHByb3BzIHJlY29tbWVuZGVkIHdoZW4gcGFuZWxzIGFyZSBkeW5hbWljYWxseSByZW5kZXJlZGApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCFkaWRMb2dQYW5lbENvbnN0cmFpbnRzV2FybmluZykge1xuICAgICAgICBjb25zdCBwYW5lbENvbnN0cmFpbnRzID0gcGFuZWxEYXRhQXJyYXkubWFwKHBhbmVsRGF0YSA9PiBwYW5lbERhdGEuY29uc3RyYWludHMpO1xuICAgICAgICBmb3IgKGxldCBwYW5lbEluZGV4ID0gMDsgcGFuZWxJbmRleCA8IHBhbmVsQ29uc3RyYWludHMubGVuZ3RoOyBwYW5lbEluZGV4KyspIHtcbiAgICAgICAgICBjb25zdCBwYW5lbERhdGEgPSBwYW5lbERhdGFBcnJheVtwYW5lbEluZGV4XTtcbiAgICAgICAgICBhc3NlcnQocGFuZWxEYXRhLCBgUGFuZWwgZGF0YSBub3QgZm91bmQgZm9yIGluZGV4ICR7cGFuZWxJbmRleH1gKTtcbiAgICAgICAgICBjb25zdCBpc1ZhbGlkID0gdmFsaWRhdGVQYW5lbENvbnN0cmFpbnRzKHtcbiAgICAgICAgICAgIHBhbmVsQ29uc3RyYWludHMsXG4gICAgICAgICAgICBwYW5lbElkOiBwYW5lbERhdGEuaWQsXG4gICAgICAgICAgICBwYW5lbEluZGV4XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaWYgKCFpc1ZhbGlkKSB7XG4gICAgICAgICAgICBkZXZXYXJuaW5nc1JlZi5jdXJyZW50LmRpZExvZ1BhbmVsQ29uc3RyYWludHNXYXJuaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbiAgLy8gRXh0ZXJuYWwgQVBJcyBhcmUgc2FmZSB0byBtZW1vaXplIHZpYSBjb21taXR0ZWQgdmFsdWVzIHJlZlxuICBjb25zdCBjb2xsYXBzZVBhbmVsID0gdXNlQ2FsbGJhY2socGFuZWxEYXRhID0+IHtcbiAgICBjb25zdCB7XG4gICAgICBvbkxheW91dFxuICAgIH0gPSBjb21taXR0ZWRWYWx1ZXNSZWYuY3VycmVudDtcbiAgICBjb25zdCB7XG4gICAgICBsYXlvdXQ6IHByZXZMYXlvdXQsXG4gICAgICBwYW5lbERhdGFBcnJheVxuICAgIH0gPSBlYWdlclZhbHVlc1JlZi5jdXJyZW50O1xuICAgIGlmIChwYW5lbERhdGEuY29uc3RyYWludHMuY29sbGFwc2libGUpIHtcbiAgICAgIGNvbnN0IHBhbmVsQ29uc3RyYWludHNBcnJheSA9IHBhbmVsRGF0YUFycmF5Lm1hcChwYW5lbERhdGEgPT4gcGFuZWxEYXRhLmNvbnN0cmFpbnRzKTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgY29sbGFwc2VkU2l6ZSA9IDAsXG4gICAgICAgIHBhbmVsU2l6ZSxcbiAgICAgICAgcGl2b3RJbmRpY2VzXG4gICAgICB9ID0gcGFuZWxEYXRhSGVscGVyKHBhbmVsRGF0YUFycmF5LCBwYW5lbERhdGEsIHByZXZMYXlvdXQpO1xuICAgICAgYXNzZXJ0KHBhbmVsU2l6ZSAhPSBudWxsLCBgUGFuZWwgc2l6ZSBub3QgZm91bmQgZm9yIHBhbmVsIFwiJHtwYW5lbERhdGEuaWR9XCJgKTtcbiAgICAgIGlmIChwYW5lbFNpemUgIT09IGNvbGxhcHNlZFNpemUpIHtcbiAgICAgICAgLy8gU3RvcmUgc2l6ZSBiZWZvcmUgY29sbGFwc2U7XG4gICAgICAgIC8vIFRoaXMgaXMgdGhlIHNpemUgdGhhdCBnZXRzIHJlc3RvcmVkIGlmIHRoZSBleHBhbmQoKSBBUEkgaXMgdXNlZC5cbiAgICAgICAgcGFuZWxTaXplQmVmb3JlQ29sbGFwc2VSZWYuY3VycmVudC5zZXQocGFuZWxEYXRhLmlkLCBwYW5lbFNpemUpO1xuICAgICAgICBjb25zdCBpc0xhc3RQYW5lbCA9IGZpbmRQYW5lbERhdGFJbmRleChwYW5lbERhdGFBcnJheSwgcGFuZWxEYXRhKSA9PT0gcGFuZWxEYXRhQXJyYXkubGVuZ3RoIC0gMTtcbiAgICAgICAgY29uc3QgZGVsdGEgPSBpc0xhc3RQYW5lbCA/IHBhbmVsU2l6ZSAtIGNvbGxhcHNlZFNpemUgOiBjb2xsYXBzZWRTaXplIC0gcGFuZWxTaXplO1xuICAgICAgICBjb25zdCBuZXh0TGF5b3V0ID0gYWRqdXN0TGF5b3V0QnlEZWx0YSh7XG4gICAgICAgICAgZGVsdGEsXG4gICAgICAgICAgaW5pdGlhbExheW91dDogcHJldkxheW91dCxcbiAgICAgICAgICBwYW5lbENvbnN0cmFpbnRzOiBwYW5lbENvbnN0cmFpbnRzQXJyYXksXG4gICAgICAgICAgcGl2b3RJbmRpY2VzLFxuICAgICAgICAgIHByZXZMYXlvdXQsXG4gICAgICAgICAgdHJpZ2dlcjogXCJpbXBlcmF0aXZlLWFwaVwiXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIWNvbXBhcmVMYXlvdXRzKHByZXZMYXlvdXQsIG5leHRMYXlvdXQpKSB7XG4gICAgICAgICAgc2V0TGF5b3V0KG5leHRMYXlvdXQpO1xuICAgICAgICAgIGVhZ2VyVmFsdWVzUmVmLmN1cnJlbnQubGF5b3V0ID0gbmV4dExheW91dDtcbiAgICAgICAgICBpZiAob25MYXlvdXQpIHtcbiAgICAgICAgICAgIG9uTGF5b3V0KG5leHRMYXlvdXQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYWxsUGFuZWxDYWxsYmFja3MocGFuZWxEYXRhQXJyYXksIG5leHRMYXlvdXQsIHBhbmVsSWRUb0xhc3ROb3RpZmllZFNpemVNYXBSZWYuY3VycmVudCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sIFtdKTtcblxuICAvLyBFeHRlcm5hbCBBUElzIGFyZSBzYWZlIHRvIG1lbW9pemUgdmlhIGNvbW1pdHRlZCB2YWx1ZXMgcmVmXG4gIGNvbnN0IGV4cGFuZFBhbmVsID0gdXNlQ2FsbGJhY2socGFuZWxEYXRhID0+IHtcbiAgICBjb25zdCB7XG4gICAgICBvbkxheW91dFxuICAgIH0gPSBjb21taXR0ZWRWYWx1ZXNSZWYuY3VycmVudDtcbiAgICBjb25zdCB7XG4gICAgICBsYXlvdXQ6IHByZXZMYXlvdXQsXG4gICAgICBwYW5lbERhdGFBcnJheVxuICAgIH0gPSBlYWdlclZhbHVlc1JlZi5jdXJyZW50O1xuICAgIGlmIChwYW5lbERhdGEuY29uc3RyYWludHMuY29sbGFwc2libGUpIHtcbiAgICAgIGNvbnN0IHBhbmVsQ29uc3RyYWludHNBcnJheSA9IHBhbmVsRGF0YUFycmF5Lm1hcChwYW5lbERhdGEgPT4gcGFuZWxEYXRhLmNvbnN0cmFpbnRzKTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgY29sbGFwc2VkU2l6ZSA9IDAsXG4gICAgICAgIHBhbmVsU2l6ZSxcbiAgICAgICAgbWluU2l6ZSA9IDAsXG4gICAgICAgIHBpdm90SW5kaWNlc1xuICAgICAgfSA9IHBhbmVsRGF0YUhlbHBlcihwYW5lbERhdGFBcnJheSwgcGFuZWxEYXRhLCBwcmV2TGF5b3V0KTtcbiAgICAgIGlmIChwYW5lbFNpemUgPT09IGNvbGxhcHNlZFNpemUpIHtcbiAgICAgICAgLy8gUmVzdG9yZSB0aGlzIHBhbmVsIHRvIHRoZSBzaXplIGl0IHdhcyBiZWZvcmUgaXQgd2FzIGNvbGxhcHNlZCwgaWYgcG9zc2libGUuXG4gICAgICAgIGNvbnN0IHByZXZQYW5lbFNpemUgPSBwYW5lbFNpemVCZWZvcmVDb2xsYXBzZVJlZi5jdXJyZW50LmdldChwYW5lbERhdGEuaWQpO1xuICAgICAgICBjb25zdCBiYXNlU2l6ZSA9IHByZXZQYW5lbFNpemUgIT0gbnVsbCAmJiBwcmV2UGFuZWxTaXplID49IG1pblNpemUgPyBwcmV2UGFuZWxTaXplIDogbWluU2l6ZTtcbiAgICAgICAgY29uc3QgaXNMYXN0UGFuZWwgPSBmaW5kUGFuZWxEYXRhSW5kZXgocGFuZWxEYXRhQXJyYXksIHBhbmVsRGF0YSkgPT09IHBhbmVsRGF0YUFycmF5Lmxlbmd0aCAtIDE7XG4gICAgICAgIGNvbnN0IGRlbHRhID0gaXNMYXN0UGFuZWwgPyBwYW5lbFNpemUgLSBiYXNlU2l6ZSA6IGJhc2VTaXplIC0gcGFuZWxTaXplO1xuICAgICAgICBjb25zdCBuZXh0TGF5b3V0ID0gYWRqdXN0TGF5b3V0QnlEZWx0YSh7XG4gICAgICAgICAgZGVsdGEsXG4gICAgICAgICAgaW5pdGlhbExheW91dDogcHJldkxheW91dCxcbiAgICAgICAgICBwYW5lbENvbnN0cmFpbnRzOiBwYW5lbENvbnN0cmFpbnRzQXJyYXksXG4gICAgICAgICAgcGl2b3RJbmRpY2VzLFxuICAgICAgICAgIHByZXZMYXlvdXQsXG4gICAgICAgICAgdHJpZ2dlcjogXCJpbXBlcmF0aXZlLWFwaVwiXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIWNvbXBhcmVMYXlvdXRzKHByZXZMYXlvdXQsIG5leHRMYXlvdXQpKSB7XG4gICAgICAgICAgc2V0TGF5b3V0KG5leHRMYXlvdXQpO1xuICAgICAgICAgIGVhZ2VyVmFsdWVzUmVmLmN1cnJlbnQubGF5b3V0ID0gbmV4dExheW91dDtcbiAgICAgICAgICBpZiAob25MYXlvdXQpIHtcbiAgICAgICAgICAgIG9uTGF5b3V0KG5leHRMYXlvdXQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYWxsUGFuZWxDYWxsYmFja3MocGFuZWxEYXRhQXJyYXksIG5leHRMYXlvdXQsIHBhbmVsSWRUb0xhc3ROb3RpZmllZFNpemVNYXBSZWYuY3VycmVudCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sIFtdKTtcblxuICAvLyBFeHRlcm5hbCBBUElzIGFyZSBzYWZlIHRvIG1lbW9pemUgdmlhIGNvbW1pdHRlZCB2YWx1ZXMgcmVmXG4gIGNvbnN0IGdldFBhbmVsU2l6ZSA9IHVzZUNhbGxiYWNrKHBhbmVsRGF0YSA9PiB7XG4gICAgY29uc3Qge1xuICAgICAgbGF5b3V0LFxuICAgICAgcGFuZWxEYXRhQXJyYXlcbiAgICB9ID0gZWFnZXJWYWx1ZXNSZWYuY3VycmVudDtcbiAgICBjb25zdCB7XG4gICAgICBwYW5lbFNpemVcbiAgICB9ID0gcGFuZWxEYXRhSGVscGVyKHBhbmVsRGF0YUFycmF5LCBwYW5lbERhdGEsIGxheW91dCk7XG4gICAgYXNzZXJ0KHBhbmVsU2l6ZSAhPSBudWxsLCBgUGFuZWwgc2l6ZSBub3QgZm91bmQgZm9yIHBhbmVsIFwiJHtwYW5lbERhdGEuaWR9XCJgKTtcbiAgICByZXR1cm4gcGFuZWxTaXplO1xuICB9LCBbXSk7XG5cbiAgLy8gVGhpcyBBUEkgc2hvdWxkIG5ldmVyIHJlYWQgZnJvbSBjb21taXR0ZWRWYWx1ZXNSZWZcbiAgY29uc3QgZ2V0UGFuZWxTdHlsZSA9IHVzZUNhbGxiYWNrKChwYW5lbERhdGEsIGRlZmF1bHRTaXplKSA9PiB7XG4gICAgY29uc3Qge1xuICAgICAgcGFuZWxEYXRhQXJyYXlcbiAgICB9ID0gZWFnZXJWYWx1ZXNSZWYuY3VycmVudDtcbiAgICBjb25zdCBwYW5lbEluZGV4ID0gZmluZFBhbmVsRGF0YUluZGV4KHBhbmVsRGF0YUFycmF5LCBwYW5lbERhdGEpO1xuICAgIHJldHVybiBjb21wdXRlUGFuZWxGbGV4Qm94U3R5bGUoe1xuICAgICAgZGVmYXVsdFNpemUsXG4gICAgICBkcmFnU3RhdGUsXG4gICAgICBsYXlvdXQsXG4gICAgICBwYW5lbERhdGE6IHBhbmVsRGF0YUFycmF5LFxuICAgICAgcGFuZWxJbmRleFxuICAgIH0pO1xuICB9LCBbZHJhZ1N0YXRlLCBsYXlvdXRdKTtcblxuICAvLyBFeHRlcm5hbCBBUElzIGFyZSBzYWZlIHRvIG1lbW9pemUgdmlhIGNvbW1pdHRlZCB2YWx1ZXMgcmVmXG4gIGNvbnN0IGlzUGFuZWxDb2xsYXBzZWQgPSB1c2VDYWxsYmFjayhwYW5lbERhdGEgPT4ge1xuICAgIGNvbnN0IHtcbiAgICAgIGxheW91dCxcbiAgICAgIHBhbmVsRGF0YUFycmF5XG4gICAgfSA9IGVhZ2VyVmFsdWVzUmVmLmN1cnJlbnQ7XG4gICAgY29uc3Qge1xuICAgICAgY29sbGFwc2VkU2l6ZSA9IDAsXG4gICAgICBjb2xsYXBzaWJsZSxcbiAgICAgIHBhbmVsU2l6ZVxuICAgIH0gPSBwYW5lbERhdGFIZWxwZXIocGFuZWxEYXRhQXJyYXksIHBhbmVsRGF0YSwgbGF5b3V0KTtcbiAgICByZXR1cm4gY29sbGFwc2libGUgPT09IHRydWUgJiYgcGFuZWxTaXplID09PSBjb2xsYXBzZWRTaXplO1xuICB9LCBbXSk7XG5cbiAgLy8gRXh0ZXJuYWwgQVBJcyBhcmUgc2FmZSB0byBtZW1vaXplIHZpYSBjb21taXR0ZWQgdmFsdWVzIHJlZlxuICBjb25zdCBpc1BhbmVsRXhwYW5kZWQgPSB1c2VDYWxsYmFjayhwYW5lbERhdGEgPT4ge1xuICAgIGNvbnN0IHtcbiAgICAgIGxheW91dCxcbiAgICAgIHBhbmVsRGF0YUFycmF5XG4gICAgfSA9IGVhZ2VyVmFsdWVzUmVmLmN1cnJlbnQ7XG4gICAgY29uc3Qge1xuICAgICAgY29sbGFwc2VkU2l6ZSA9IDAsXG4gICAgICBjb2xsYXBzaWJsZSxcbiAgICAgIHBhbmVsU2l6ZVxuICAgIH0gPSBwYW5lbERhdGFIZWxwZXIocGFuZWxEYXRhQXJyYXksIHBhbmVsRGF0YSwgbGF5b3V0KTtcbiAgICBhc3NlcnQocGFuZWxTaXplICE9IG51bGwsIGBQYW5lbCBzaXplIG5vdCBmb3VuZCBmb3IgcGFuZWwgXCIke3BhbmVsRGF0YS5pZH1cImApO1xuICAgIHJldHVybiAhY29sbGFwc2libGUgfHwgcGFuZWxTaXplID4gY29sbGFwc2VkU2l6ZTtcbiAgfSwgW10pO1xuICBjb25zdCByZWdpc3RlclBhbmVsID0gdXNlQ2FsbGJhY2socGFuZWxEYXRhID0+IHtcbiAgICBjb25zdCB7XG4gICAgICBwYW5lbERhdGFBcnJheVxuICAgIH0gPSBlYWdlclZhbHVlc1JlZi5jdXJyZW50O1xuICAgIHBhbmVsRGF0YUFycmF5LnB1c2gocGFuZWxEYXRhKTtcbiAgICBwYW5lbERhdGFBcnJheS5zb3J0KChwYW5lbEEsIHBhbmVsQikgPT4ge1xuICAgICAgY29uc3Qgb3JkZXJBID0gcGFuZWxBLm9yZGVyO1xuICAgICAgY29uc3Qgb3JkZXJCID0gcGFuZWxCLm9yZGVyO1xuICAgICAgaWYgKG9yZGVyQSA9PSBudWxsICYmIG9yZGVyQiA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfSBlbHNlIGlmIChvcmRlckEgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgICB9IGVsc2UgaWYgKG9yZGVyQiA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG9yZGVyQSAtIG9yZGVyQjtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBlYWdlclZhbHVlc1JlZi5jdXJyZW50LnBhbmVsRGF0YUFycmF5Q2hhbmdlZCA9IHRydWU7XG4gIH0sIFtdKTtcbiAgY29uc3QgcmVnaXN0ZXJSZXNpemVIYW5kbGUgPSB1c2VDYWxsYmFjayhkcmFnSGFuZGxlSWQgPT4ge1xuICAgIHJldHVybiBmdW5jdGlvbiByZXNpemVIYW5kbGVyKGV2ZW50KSB7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgY29uc3QgcGFuZWxHcm91cEVsZW1lbnQgPSBwYW5lbEdyb3VwRWxlbWVudFJlZi5jdXJyZW50O1xuICAgICAgaWYgKCFwYW5lbEdyb3VwRWxlbWVudCkge1xuICAgICAgICByZXR1cm4gKCkgPT4gbnVsbDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHtcbiAgICAgICAgZGlyZWN0aW9uLFxuICAgICAgICBkcmFnU3RhdGUsXG4gICAgICAgIGlkOiBncm91cElkLFxuICAgICAgICBrZXlib2FyZFJlc2l6ZUJ5LFxuICAgICAgICBvbkxheW91dFxuICAgICAgfSA9IGNvbW1pdHRlZFZhbHVlc1JlZi5jdXJyZW50O1xuICAgICAgY29uc3Qge1xuICAgICAgICBsYXlvdXQ6IHByZXZMYXlvdXQsXG4gICAgICAgIHBhbmVsRGF0YUFycmF5XG4gICAgICB9ID0gZWFnZXJWYWx1ZXNSZWYuY3VycmVudDtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgaW5pdGlhbExheW91dFxuICAgICAgfSA9IGRyYWdTdGF0ZSAhPT0gbnVsbCAmJiBkcmFnU3RhdGUgIT09IHZvaWQgMCA/IGRyYWdTdGF0ZSA6IHt9O1xuICAgICAgY29uc3QgcGl2b3RJbmRpY2VzID0gZGV0ZXJtaW5lUGl2b3RJbmRpY2VzKGdyb3VwSWQsIGRyYWdIYW5kbGVJZCwgcGFuZWxHcm91cEVsZW1lbnQpO1xuICAgICAgbGV0IGRlbHRhID0gY2FsY3VsYXRlRGVsdGFQZXJjZW50YWdlKGV2ZW50LCBkcmFnSGFuZGxlSWQsIGRpcmVjdGlvbiwgZHJhZ1N0YXRlLCBrZXlib2FyZFJlc2l6ZUJ5LCBwYW5lbEdyb3VwRWxlbWVudCk7XG4gICAgICBpZiAoZGVsdGEgPT09IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBTdXBwb3J0IFJUTCBsYXlvdXRzXG4gICAgICBjb25zdCBpc0hvcml6b250YWwgPSBkaXJlY3Rpb24gPT09IFwiaG9yaXpvbnRhbFwiO1xuICAgICAgaWYgKGRvY3VtZW50LmRpciA9PT0gXCJydGxcIiAmJiBpc0hvcml6b250YWwpIHtcbiAgICAgICAgZGVsdGEgPSAtZGVsdGE7XG4gICAgICB9XG4gICAgICBjb25zdCBwYW5lbENvbnN0cmFpbnRzID0gcGFuZWxEYXRhQXJyYXkubWFwKHBhbmVsRGF0YSA9PiBwYW5lbERhdGEuY29uc3RyYWludHMpO1xuICAgICAgY29uc3QgbmV4dExheW91dCA9IGFkanVzdExheW91dEJ5RGVsdGEoe1xuICAgICAgICBkZWx0YSxcbiAgICAgICAgaW5pdGlhbExheW91dDogaW5pdGlhbExheW91dCAhPT0gbnVsbCAmJiBpbml0aWFsTGF5b3V0ICE9PSB2b2lkIDAgPyBpbml0aWFsTGF5b3V0IDogcHJldkxheW91dCxcbiAgICAgICAgcGFuZWxDb25zdHJhaW50cyxcbiAgICAgICAgcGl2b3RJbmRpY2VzLFxuICAgICAgICBwcmV2TGF5b3V0LFxuICAgICAgICB0cmlnZ2VyOiBpc0tleURvd24oZXZlbnQpID8gXCJrZXlib2FyZFwiIDogXCJtb3VzZS1vci10b3VjaFwiXG4gICAgICB9KTtcbiAgICAgIGNvbnN0IGxheW91dENoYW5nZWQgPSAhY29tcGFyZUxheW91dHMocHJldkxheW91dCwgbmV4dExheW91dCk7XG5cbiAgICAgIC8vIE9ubHkgdXBkYXRlIHRoZSBjdXJzb3IgZm9yIGxheW91dCBjaGFuZ2VzIHRyaWdnZXJlZCBieSB0b3VjaC9tb3VzZSBldmVudHMgKG5vdCBrZXlib2FyZClcbiAgICAgIC8vIFVwZGF0ZSB0aGUgY3Vyc29yIGV2ZW4gaWYgdGhlIGxheW91dCBoYXNuJ3QgY2hhbmdlZCAod2UgbWF5IG5lZWQgdG8gc2hvdyBhbiBpbnZhbGlkIGN1cnNvciBzdGF0ZSlcbiAgICAgIGlmIChpc01vdXNlRXZlbnQoZXZlbnQpIHx8IGlzVG91Y2hFdmVudChldmVudCkpIHtcbiAgICAgICAgLy8gV2F0Y2ggZm9yIG11bHRpcGxlIHN1YnNlcXVlbnQgZGVsdGFzOyB0aGlzIG1pZ2h0IG9jY3VyIGZvciB0aW55IGN1cnNvciBtb3ZlbWVudHMuXG4gICAgICAgIC8vIEluIHRoaXMgY2FzZSwgUGFuZWwgc2l6ZXMgbWlnaHQgbm90IGNoYW5nZeKAk1xuICAgICAgICAvLyBidXQgdXBkYXRpbmcgY3Vyc29yIGluIHRoaXMgc2NlbmFyaW8gd291bGQgY2F1c2UgYSBmbGlja2VyLlxuICAgICAgICBpZiAocHJldkRlbHRhUmVmLmN1cnJlbnQgIT0gZGVsdGEpIHtcbiAgICAgICAgICBwcmV2RGVsdGFSZWYuY3VycmVudCA9IGRlbHRhO1xuICAgICAgICAgIGlmICghbGF5b3V0Q2hhbmdlZCkge1xuICAgICAgICAgICAgLy8gSWYgdGhlIHBvaW50ZXIgaGFzIG1vdmVkIHRvbyBmYXIgdG8gcmVzaXplIHRoZSBwYW5lbCBhbnkgZnVydGhlciwgbm90ZSB0aGlzIHNvIHdlIGNhbiB1cGRhdGUgdGhlIGN1cnNvci5cbiAgICAgICAgICAgIC8vIFRoaXMgbWltaWNzIFZTIENvZGUgYmVoYXZpb3IuXG4gICAgICAgICAgICBpZiAoaXNIb3Jpem9udGFsKSB7XG4gICAgICAgICAgICAgIHJlcG9ydENvbnN0cmFpbnRzVmlvbGF0aW9uKGRyYWdIYW5kbGVJZCwgZGVsdGEgPCAwID8gRVhDRUVERURfSE9SSVpPTlRBTF9NSU4gOiBFWENFRURFRF9IT1JJWk9OVEFMX01BWCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXBvcnRDb25zdHJhaW50c1Zpb2xhdGlvbihkcmFnSGFuZGxlSWQsIGRlbHRhIDwgMCA/IEVYQ0VFREVEX1ZFUlRJQ0FMX01JTiA6IEVYQ0VFREVEX1ZFUlRJQ0FMX01BWCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlcG9ydENvbnN0cmFpbnRzVmlvbGF0aW9uKGRyYWdIYW5kbGVJZCwgMCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAobGF5b3V0Q2hhbmdlZCkge1xuICAgICAgICBzZXRMYXlvdXQobmV4dExheW91dCk7XG4gICAgICAgIGVhZ2VyVmFsdWVzUmVmLmN1cnJlbnQubGF5b3V0ID0gbmV4dExheW91dDtcbiAgICAgICAgaWYgKG9uTGF5b3V0KSB7XG4gICAgICAgICAgb25MYXlvdXQobmV4dExheW91dCk7XG4gICAgICAgIH1cbiAgICAgICAgY2FsbFBhbmVsQ2FsbGJhY2tzKHBhbmVsRGF0YUFycmF5LCBuZXh0TGF5b3V0LCBwYW5lbElkVG9MYXN0Tm90aWZpZWRTaXplTWFwUmVmLmN1cnJlbnQpO1xuICAgICAgfVxuICAgIH07XG4gIH0sIFtdKTtcblxuICAvLyBFeHRlcm5hbCBBUElzIGFyZSBzYWZlIHRvIG1lbW9pemUgdmlhIGNvbW1pdHRlZCB2YWx1ZXMgcmVmXG4gIGNvbnN0IHJlc2l6ZVBhbmVsID0gdXNlQ2FsbGJhY2soKHBhbmVsRGF0YSwgdW5zYWZlUGFuZWxTaXplKSA9PiB7XG4gICAgY29uc3Qge1xuICAgICAgb25MYXlvdXRcbiAgICB9ID0gY29tbWl0dGVkVmFsdWVzUmVmLmN1cnJlbnQ7XG4gICAgY29uc3Qge1xuICAgICAgbGF5b3V0OiBwcmV2TGF5b3V0LFxuICAgICAgcGFuZWxEYXRhQXJyYXlcbiAgICB9ID0gZWFnZXJWYWx1ZXNSZWYuY3VycmVudDtcbiAgICBjb25zdCBwYW5lbENvbnN0cmFpbnRzQXJyYXkgPSBwYW5lbERhdGFBcnJheS5tYXAocGFuZWxEYXRhID0+IHBhbmVsRGF0YS5jb25zdHJhaW50cyk7XG4gICAgY29uc3Qge1xuICAgICAgcGFuZWxTaXplLFxuICAgICAgcGl2b3RJbmRpY2VzXG4gICAgfSA9IHBhbmVsRGF0YUhlbHBlcihwYW5lbERhdGFBcnJheSwgcGFuZWxEYXRhLCBwcmV2TGF5b3V0KTtcbiAgICBhc3NlcnQocGFuZWxTaXplICE9IG51bGwsIGBQYW5lbCBzaXplIG5vdCBmb3VuZCBmb3IgcGFuZWwgXCIke3BhbmVsRGF0YS5pZH1cImApO1xuICAgIGNvbnN0IGlzTGFzdFBhbmVsID0gZmluZFBhbmVsRGF0YUluZGV4KHBhbmVsRGF0YUFycmF5LCBwYW5lbERhdGEpID09PSBwYW5lbERhdGFBcnJheS5sZW5ndGggLSAxO1xuICAgIGNvbnN0IGRlbHRhID0gaXNMYXN0UGFuZWwgPyBwYW5lbFNpemUgLSB1bnNhZmVQYW5lbFNpemUgOiB1bnNhZmVQYW5lbFNpemUgLSBwYW5lbFNpemU7XG4gICAgY29uc3QgbmV4dExheW91dCA9IGFkanVzdExheW91dEJ5RGVsdGEoe1xuICAgICAgZGVsdGEsXG4gICAgICBpbml0aWFsTGF5b3V0OiBwcmV2TGF5b3V0LFxuICAgICAgcGFuZWxDb25zdHJhaW50czogcGFuZWxDb25zdHJhaW50c0FycmF5LFxuICAgICAgcGl2b3RJbmRpY2VzLFxuICAgICAgcHJldkxheW91dCxcbiAgICAgIHRyaWdnZXI6IFwiaW1wZXJhdGl2ZS1hcGlcIlxuICAgIH0pO1xuICAgIGlmICghY29tcGFyZUxheW91dHMocHJldkxheW91dCwgbmV4dExheW91dCkpIHtcbiAgICAgIHNldExheW91dChuZXh0TGF5b3V0KTtcbiAgICAgIGVhZ2VyVmFsdWVzUmVmLmN1cnJlbnQubGF5b3V0ID0gbmV4dExheW91dDtcbiAgICAgIGlmIChvbkxheW91dCkge1xuICAgICAgICBvbkxheW91dChuZXh0TGF5b3V0KTtcbiAgICAgIH1cbiAgICAgIGNhbGxQYW5lbENhbGxiYWNrcyhwYW5lbERhdGFBcnJheSwgbmV4dExheW91dCwgcGFuZWxJZFRvTGFzdE5vdGlmaWVkU2l6ZU1hcFJlZi5jdXJyZW50KTtcbiAgICB9XG4gIH0sIFtdKTtcbiAgY29uc3QgcmVldmFsdWF0ZVBhbmVsQ29uc3RyYWludHMgPSB1c2VDYWxsYmFjaygocGFuZWxEYXRhLCBwcmV2Q29uc3RyYWludHMpID0+IHtcbiAgICBjb25zdCB7XG4gICAgICBsYXlvdXQsXG4gICAgICBwYW5lbERhdGFBcnJheVxuICAgIH0gPSBlYWdlclZhbHVlc1JlZi5jdXJyZW50O1xuICAgIGNvbnN0IHtcbiAgICAgIGNvbGxhcHNlZFNpemU6IHByZXZDb2xsYXBzZWRTaXplID0gMCxcbiAgICAgIGNvbGxhcHNpYmxlOiBwcmV2Q29sbGFwc2libGVcbiAgICB9ID0gcHJldkNvbnN0cmFpbnRzO1xuICAgIGNvbnN0IHtcbiAgICAgIGNvbGxhcHNlZFNpemU6IG5leHRDb2xsYXBzZWRTaXplID0gMCxcbiAgICAgIGNvbGxhcHNpYmxlOiBuZXh0Q29sbGFwc2libGUsXG4gICAgICBtYXhTaXplOiBuZXh0TWF4U2l6ZSA9IDEwMCxcbiAgICAgIG1pblNpemU6IG5leHRNaW5TaXplID0gMFxuICAgIH0gPSBwYW5lbERhdGEuY29uc3RyYWludHM7XG4gICAgY29uc3Qge1xuICAgICAgcGFuZWxTaXplOiBwcmV2UGFuZWxTaXplXG4gICAgfSA9IHBhbmVsRGF0YUhlbHBlcihwYW5lbERhdGFBcnJheSwgcGFuZWxEYXRhLCBsYXlvdXQpO1xuICAgIGlmIChwcmV2UGFuZWxTaXplID09IG51bGwpIHtcbiAgICAgIC8vIEl0J3MgcG9zc2libGUgdGhhdCB0aGUgcGFuZWxzIGluIHRoaXMgZ3JvdXAgaGF2ZSBjaGFuZ2VkIHNpbmNlIHRoZSBsYXN0IHJlbmRlclxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAocHJldkNvbGxhcHNpYmxlICYmIG5leHRDb2xsYXBzaWJsZSAmJiBwcmV2UGFuZWxTaXplID09PSBwcmV2Q29sbGFwc2VkU2l6ZSkge1xuICAgICAgaWYgKHByZXZDb2xsYXBzZWRTaXplICE9PSBuZXh0Q29sbGFwc2VkU2l6ZSkge1xuICAgICAgICByZXNpemVQYW5lbChwYW5lbERhdGEsIG5leHRDb2xsYXBzZWRTaXplKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHByZXZQYW5lbFNpemUgPCBuZXh0TWluU2l6ZSkge1xuICAgICAgcmVzaXplUGFuZWwocGFuZWxEYXRhLCBuZXh0TWluU2l6ZSk7XG4gICAgfSBlbHNlIGlmIChwcmV2UGFuZWxTaXplID4gbmV4dE1heFNpemUpIHtcbiAgICAgIHJlc2l6ZVBhbmVsKHBhbmVsRGF0YSwgbmV4dE1heFNpemUpO1xuICAgIH1cbiAgfSwgW3Jlc2l6ZVBhbmVsXSk7XG4gIGNvbnN0IHN0YXJ0RHJhZ2dpbmcgPSB1c2VDYWxsYmFjaygoZHJhZ0hhbmRsZUlkLCBldmVudCkgPT4ge1xuICAgIGNvbnN0IHtcbiAgICAgIGRpcmVjdGlvblxuICAgIH0gPSBjb21taXR0ZWRWYWx1ZXNSZWYuY3VycmVudDtcbiAgICBjb25zdCB7XG4gICAgICBsYXlvdXRcbiAgICB9ID0gZWFnZXJWYWx1ZXNSZWYuY3VycmVudDtcbiAgICBpZiAoIXBhbmVsR3JvdXBFbGVtZW50UmVmLmN1cnJlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgaGFuZGxlRWxlbWVudCA9IGdldFJlc2l6ZUhhbmRsZUVsZW1lbnQoZHJhZ0hhbmRsZUlkLCBwYW5lbEdyb3VwRWxlbWVudFJlZi5jdXJyZW50KTtcbiAgICBhc3NlcnQoaGFuZGxlRWxlbWVudCwgYERyYWcgaGFuZGxlIGVsZW1lbnQgbm90IGZvdW5kIGZvciBpZCBcIiR7ZHJhZ0hhbmRsZUlkfVwiYCk7XG4gICAgY29uc3QgaW5pdGlhbEN1cnNvclBvc2l0aW9uID0gZ2V0UmVzaXplRXZlbnRDdXJzb3JQb3NpdGlvbihkaXJlY3Rpb24sIGV2ZW50KTtcbiAgICBzZXREcmFnU3RhdGUoe1xuICAgICAgZHJhZ0hhbmRsZUlkLFxuICAgICAgZHJhZ0hhbmRsZVJlY3Q6IGhhbmRsZUVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksXG4gICAgICBpbml0aWFsQ3Vyc29yUG9zaXRpb24sXG4gICAgICBpbml0aWFsTGF5b3V0OiBsYXlvdXRcbiAgICB9KTtcbiAgfSwgW10pO1xuICBjb25zdCBzdG9wRHJhZ2dpbmcgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgc2V0RHJhZ1N0YXRlKG51bGwpO1xuICB9LCBbXSk7XG4gIGNvbnN0IHVucmVnaXN0ZXJQYW5lbCA9IHVzZUNhbGxiYWNrKHBhbmVsRGF0YSA9PiB7XG4gICAgY29uc3Qge1xuICAgICAgcGFuZWxEYXRhQXJyYXlcbiAgICB9ID0gZWFnZXJWYWx1ZXNSZWYuY3VycmVudDtcbiAgICBjb25zdCBpbmRleCA9IGZpbmRQYW5lbERhdGFJbmRleChwYW5lbERhdGFBcnJheSwgcGFuZWxEYXRhKTtcbiAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgcGFuZWxEYXRhQXJyYXkuc3BsaWNlKGluZGV4LCAxKTtcblxuICAgICAgLy8gVFJJQ0tZXG4gICAgICAvLyBXaGVuIGEgcGFuZWwgaXMgcmVtb3ZlZCBmcm9tIHRoZSBncm91cCwgd2Ugc2hvdWxkIGRlbGV0ZSB0aGUgbW9zdCByZWNlbnQgcHJldi1zaXplIGVudHJ5IGZvciBpdC5cbiAgICAgIC8vIElmIHdlIGRvbid0IGRvIHRoaXMsIHRoZW4gYSBjb25kaXRpb25hbGx5IHJlbmRlcmVkIHBhbmVsIG1pZ2h0IG5vdCBjYWxsIG9uUmVzaXplIHdoZW4gaXQncyByZS1tb3VudGVkLlxuICAgICAgLy8gU3RyaWN0IGVmZmVjdHMgbW9kZSBtYWtlcyB0aGlzIHRyaWNreSB0aG91Z2ggYmVjYXVzZSBhbGwgcGFuZWxzIHdpbGwgYmUgcmVnaXN0ZXJlZCwgdW5yZWdpc3RlcmVkLCB0aGVuIHJlLXJlZ2lzdGVyZWQgb24gbW91bnQuXG4gICAgICBkZWxldGUgcGFuZWxJZFRvTGFzdE5vdGlmaWVkU2l6ZU1hcFJlZi5jdXJyZW50W3BhbmVsRGF0YS5pZF07XG4gICAgICBlYWdlclZhbHVlc1JlZi5jdXJyZW50LnBhbmVsRGF0YUFycmF5Q2hhbmdlZCA9IHRydWU7XG4gICAgfVxuICB9LCBbXSk7XG4gIGNvbnN0IGNvbnRleHQgPSB1c2VNZW1vKCgpID0+ICh7XG4gICAgY29sbGFwc2VQYW5lbCxcbiAgICBkaXJlY3Rpb24sXG4gICAgZHJhZ1N0YXRlLFxuICAgIGV4cGFuZFBhbmVsLFxuICAgIGdldFBhbmVsU2l6ZSxcbiAgICBnZXRQYW5lbFN0eWxlLFxuICAgIGdyb3VwSWQsXG4gICAgaXNQYW5lbENvbGxhcHNlZCxcbiAgICBpc1BhbmVsRXhwYW5kZWQsXG4gICAgcmVldmFsdWF0ZVBhbmVsQ29uc3RyYWludHMsXG4gICAgcmVnaXN0ZXJQYW5lbCxcbiAgICByZWdpc3RlclJlc2l6ZUhhbmRsZSxcbiAgICByZXNpemVQYW5lbCxcbiAgICBzdGFydERyYWdnaW5nLFxuICAgIHN0b3BEcmFnZ2luZyxcbiAgICB1bnJlZ2lzdGVyUGFuZWwsXG4gICAgcGFuZWxHcm91cEVsZW1lbnQ6IHBhbmVsR3JvdXBFbGVtZW50UmVmLmN1cnJlbnRcbiAgfSksIFtjb2xsYXBzZVBhbmVsLCBkcmFnU3RhdGUsIGRpcmVjdGlvbiwgZXhwYW5kUGFuZWwsIGdldFBhbmVsU2l6ZSwgZ2V0UGFuZWxTdHlsZSwgZ3JvdXBJZCwgaXNQYW5lbENvbGxhcHNlZCwgaXNQYW5lbEV4cGFuZGVkLCByZWV2YWx1YXRlUGFuZWxDb25zdHJhaW50cywgcmVnaXN0ZXJQYW5lbCwgcmVnaXN0ZXJSZXNpemVIYW5kbGUsIHJlc2l6ZVBhbmVsLCBzdGFydERyYWdnaW5nLCBzdG9wRHJhZ2dpbmcsIHVucmVnaXN0ZXJQYW5lbF0pO1xuICBjb25zdCBzdHlsZSA9IHtcbiAgICBkaXNwbGF5OiBcImZsZXhcIixcbiAgICBmbGV4RGlyZWN0aW9uOiBkaXJlY3Rpb24gPT09IFwiaG9yaXpvbnRhbFwiID8gXCJyb3dcIiA6IFwiY29sdW1uXCIsXG4gICAgaGVpZ2h0OiBcIjEwMCVcIixcbiAgICBvdmVyZmxvdzogXCJoaWRkZW5cIixcbiAgICB3aWR0aDogXCIxMDAlXCJcbiAgfTtcbiAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQoUGFuZWxHcm91cENvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogY29udGV4dFxuICB9LCBjcmVhdGVFbGVtZW50KFR5cGUsIHtcbiAgICAuLi5yZXN0LFxuICAgIGNoaWxkcmVuLFxuICAgIGNsYXNzTmFtZTogY2xhc3NOYW1lRnJvbVByb3BzLFxuICAgIGlkOiBpZEZyb21Qcm9wcyxcbiAgICByZWY6IHBhbmVsR3JvdXBFbGVtZW50UmVmLFxuICAgIHN0eWxlOiB7XG4gICAgICAuLi5zdHlsZSxcbiAgICAgIC4uLnN0eWxlRnJvbVByb3BzXG4gICAgfSxcbiAgICAvLyBDU1Mgc2VsZWN0b3JzXG4gICAgXCJkYXRhLXBhbmVsLWdyb3VwXCI6IFwiXCIsXG4gICAgXCJkYXRhLXBhbmVsLWdyb3VwLWRpcmVjdGlvblwiOiBkaXJlY3Rpb24sXG4gICAgXCJkYXRhLXBhbmVsLWdyb3VwLWlkXCI6IGdyb3VwSWRcbiAgfSkpO1xufVxuY29uc3QgUGFuZWxHcm91cCA9IGZvcndhcmRSZWYoKHByb3BzLCByZWYpID0+IGNyZWF0ZUVsZW1lbnQoUGFuZWxHcm91cFdpdGhGb3J3YXJkZWRSZWYsIHtcbiAgLi4ucHJvcHMsXG4gIGZvcndhcmRlZFJlZjogcmVmXG59KSk7XG5QYW5lbEdyb3VwV2l0aEZvcndhcmRlZFJlZi5kaXNwbGF5TmFtZSA9IFwiUGFuZWxHcm91cFwiO1xuUGFuZWxHcm91cC5kaXNwbGF5TmFtZSA9IFwiZm9yd2FyZFJlZihQYW5lbEdyb3VwKVwiO1xuZnVuY3Rpb24gZmluZFBhbmVsRGF0YUluZGV4KHBhbmVsRGF0YUFycmF5LCBwYW5lbERhdGEpIHtcbiAgcmV0dXJuIHBhbmVsRGF0YUFycmF5LmZpbmRJbmRleChwcmV2UGFuZWxEYXRhID0+IHByZXZQYW5lbERhdGEgPT09IHBhbmVsRGF0YSB8fCBwcmV2UGFuZWxEYXRhLmlkID09PSBwYW5lbERhdGEuaWQpO1xufVxuZnVuY3Rpb24gcGFuZWxEYXRhSGVscGVyKHBhbmVsRGF0YUFycmF5LCBwYW5lbERhdGEsIGxheW91dCkge1xuICBjb25zdCBwYW5lbEluZGV4ID0gZmluZFBhbmVsRGF0YUluZGV4KHBhbmVsRGF0YUFycmF5LCBwYW5lbERhdGEpO1xuICBjb25zdCBpc0xhc3RQYW5lbCA9IHBhbmVsSW5kZXggPT09IHBhbmVsRGF0YUFycmF5Lmxlbmd0aCAtIDE7XG4gIGNvbnN0IHBpdm90SW5kaWNlcyA9IGlzTGFzdFBhbmVsID8gW3BhbmVsSW5kZXggLSAxLCBwYW5lbEluZGV4XSA6IFtwYW5lbEluZGV4LCBwYW5lbEluZGV4ICsgMV07XG4gIGNvbnN0IHBhbmVsU2l6ZSA9IGxheW91dFtwYW5lbEluZGV4XTtcbiAgcmV0dXJuIHtcbiAgICAuLi5wYW5lbERhdGEuY29uc3RyYWludHMsXG4gICAgcGFuZWxTaXplLFxuICAgIHBpdm90SW5kaWNlc1xuICB9O1xufVxuXG4vLyBodHRwczovL3d3dy53My5vcmcvV0FJL0FSSUEvYXBnL3BhdHRlcm5zL3dpbmRvd3NwbGl0dGVyL1xuXG5mdW5jdGlvbiB1c2VXaW5kb3dTcGxpdHRlclJlc2l6ZUhhbmRsZXJCZWhhdmlvcih7XG4gIGRpc2FibGVkLFxuICBoYW5kbGVJZCxcbiAgcmVzaXplSGFuZGxlcixcbiAgcGFuZWxHcm91cEVsZW1lbnRcbn0pIHtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoZGlzYWJsZWQgfHwgcmVzaXplSGFuZGxlciA9PSBudWxsIHx8IHBhbmVsR3JvdXBFbGVtZW50ID09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgaGFuZGxlRWxlbWVudCA9IGdldFJlc2l6ZUhhbmRsZUVsZW1lbnQoaGFuZGxlSWQsIHBhbmVsR3JvdXBFbGVtZW50KTtcbiAgICBpZiAoaGFuZGxlRWxlbWVudCA9PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IG9uS2V5RG93biA9IGV2ZW50ID0+IHtcbiAgICAgIGlmIChldmVudC5kZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHN3aXRjaCAoZXZlbnQua2V5KSB7XG4gICAgICAgIGNhc2UgXCJBcnJvd0Rvd25cIjpcbiAgICAgICAgY2FzZSBcIkFycm93TGVmdFwiOlxuICAgICAgICBjYXNlIFwiQXJyb3dSaWdodFwiOlxuICAgICAgICBjYXNlIFwiQXJyb3dVcFwiOlxuICAgICAgICBjYXNlIFwiRW5kXCI6XG4gICAgICAgIGNhc2UgXCJIb21lXCI6XG4gICAgICAgICAge1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIHJlc2l6ZUhhbmRsZXIoZXZlbnQpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICBjYXNlIFwiRjZcIjpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgY29uc3QgZ3JvdXBJZCA9IGhhbmRsZUVsZW1lbnQuZ2V0QXR0cmlidXRlKFwiZGF0YS1wYW5lbC1ncm91cC1pZFwiKTtcbiAgICAgICAgICAgIGFzc2VydChncm91cElkLCBgTm8gZ3JvdXAgZWxlbWVudCBmb3VuZCBmb3IgaWQgXCIke2dyb3VwSWR9XCJgKTtcbiAgICAgICAgICAgIGNvbnN0IGhhbmRsZXMgPSBnZXRSZXNpemVIYW5kbGVFbGVtZW50c0Zvckdyb3VwKGdyb3VwSWQsIHBhbmVsR3JvdXBFbGVtZW50KTtcbiAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gZ2V0UmVzaXplSGFuZGxlRWxlbWVudEluZGV4KGdyb3VwSWQsIGhhbmRsZUlkLCBwYW5lbEdyb3VwRWxlbWVudCk7XG4gICAgICAgICAgICBhc3NlcnQoaW5kZXggIT09IG51bGwsIGBObyByZXNpemUgZWxlbWVudCBmb3VuZCBmb3IgaWQgXCIke2hhbmRsZUlkfVwiYCk7XG4gICAgICAgICAgICBjb25zdCBuZXh0SW5kZXggPSBldmVudC5zaGlmdEtleSA/IGluZGV4ID4gMCA/IGluZGV4IC0gMSA6IGhhbmRsZXMubGVuZ3RoIC0gMSA6IGluZGV4ICsgMSA8IGhhbmRsZXMubGVuZ3RoID8gaW5kZXggKyAxIDogMDtcbiAgICAgICAgICAgIGNvbnN0IG5leHRIYW5kbGUgPSBoYW5kbGVzW25leHRJbmRleF07XG4gICAgICAgICAgICBuZXh0SGFuZGxlLmZvY3VzKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICBoYW5kbGVFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIG9uS2V5RG93bik7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGhhbmRsZUVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgb25LZXlEb3duKTtcbiAgICB9O1xuICB9LCBbcGFuZWxHcm91cEVsZW1lbnQsIGRpc2FibGVkLCBoYW5kbGVJZCwgcmVzaXplSGFuZGxlcl0pO1xufVxuXG5mdW5jdGlvbiBQYW5lbFJlc2l6ZUhhbmRsZSh7XG4gIGNoaWxkcmVuID0gbnVsbCxcbiAgY2xhc3NOYW1lOiBjbGFzc05hbWVGcm9tUHJvcHMgPSBcIlwiLFxuICBkaXNhYmxlZCA9IGZhbHNlLFxuICBoaXRBcmVhTWFyZ2lucyxcbiAgaWQ6IGlkRnJvbVByb3BzLFxuICBvbkRyYWdnaW5nLFxuICBzdHlsZTogc3R5bGVGcm9tUHJvcHMgPSB7fSxcbiAgdGFiSW5kZXggPSAwLFxuICB0YWdOYW1lOiBUeXBlID0gXCJkaXZcIixcbiAgLi4ucmVzdFxufSkge1xuICBjb25zdCBlbGVtZW50UmVmID0gdXNlUmVmKG51bGwpO1xuXG4gIC8vIFVzZSBhIHJlZiB0byBndWFyZCBhZ2FpbnN0IHVzZXJzIHBhc3NpbmcgaW5saW5lIHByb3BzXG4gIGNvbnN0IGNhbGxiYWNrc1JlZiA9IHVzZVJlZih7XG4gICAgb25EcmFnZ2luZ1xuICB9KTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjYWxsYmFja3NSZWYuY3VycmVudC5vbkRyYWdnaW5nID0gb25EcmFnZ2luZztcbiAgfSk7XG4gIGNvbnN0IHBhbmVsR3JvdXBDb250ZXh0ID0gdXNlQ29udGV4dChQYW5lbEdyb3VwQ29udGV4dCk7XG4gIGlmIChwYW5lbEdyb3VwQ29udGV4dCA9PT0gbnVsbCkge1xuICAgIHRocm93IEVycm9yKGBQYW5lbFJlc2l6ZUhhbmRsZSBjb21wb25lbnRzIG11c3QgYmUgcmVuZGVyZWQgd2l0aGluIGEgUGFuZWxHcm91cCBjb250YWluZXJgKTtcbiAgfVxuICBjb25zdCB7XG4gICAgZGlyZWN0aW9uLFxuICAgIGdyb3VwSWQsXG4gICAgcmVnaXN0ZXJSZXNpemVIYW5kbGU6IHJlZ2lzdGVyUmVzaXplSGFuZGxlV2l0aFBhcmVudEdyb3VwLFxuICAgIHN0YXJ0RHJhZ2dpbmcsXG4gICAgc3RvcERyYWdnaW5nLFxuICAgIHBhbmVsR3JvdXBFbGVtZW50XG4gIH0gPSBwYW5lbEdyb3VwQ29udGV4dDtcbiAgY29uc3QgcmVzaXplSGFuZGxlSWQgPSB1c2VVbmlxdWVJZChpZEZyb21Qcm9wcyk7XG4gIGNvbnN0IFtzdGF0ZSwgc2V0U3RhdGVdID0gdXNlU3RhdGUoXCJpbmFjdGl2ZVwiKTtcbiAgY29uc3QgW2lzRm9jdXNlZCwgc2V0SXNGb2N1c2VkXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgY29uc3QgW3Jlc2l6ZUhhbmRsZXIsIHNldFJlc2l6ZUhhbmRsZXJdID0gdXNlU3RhdGUobnVsbCk7XG4gIGNvbnN0IGNvbW1pdHRlZFZhbHVlc1JlZiA9IHVzZVJlZih7XG4gICAgc3RhdGVcbiAgfSk7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKGRpc2FibGVkKSB7XG4gICAgICBzZXRSZXNpemVIYW5kbGVyKG51bGwpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCByZXNpemVIYW5kbGVyID0gcmVnaXN0ZXJSZXNpemVIYW5kbGVXaXRoUGFyZW50R3JvdXAocmVzaXplSGFuZGxlSWQpO1xuICAgICAgc2V0UmVzaXplSGFuZGxlcigoKSA9PiByZXNpemVIYW5kbGVyKTtcbiAgICB9XG4gIH0sIFtkaXNhYmxlZCwgcmVzaXplSGFuZGxlSWQsIHJlZ2lzdGVyUmVzaXplSGFuZGxlV2l0aFBhcmVudEdyb3VwXSk7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgdmFyIF9oaXRBcmVhTWFyZ2lucyRjb2FycywgX2hpdEFyZWFNYXJnaW5zJGZpbmU7XG4gICAgaWYgKGRpc2FibGVkIHx8IHJlc2l6ZUhhbmRsZXIgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBlbGVtZW50ID0gZWxlbWVudFJlZi5jdXJyZW50O1xuICAgIGFzc2VydChlbGVtZW50LCBcIkVsZW1lbnQgcmVmIG5vdCBhdHRhY2hlZFwiKTtcbiAgICBjb25zdCBzZXRSZXNpemVIYW5kbGVyU3RhdGUgPSAoYWN0aW9uLCBpc0FjdGl2ZSwgZXZlbnQpID0+IHtcbiAgICAgIGlmIChpc0FjdGl2ZSkge1xuICAgICAgICBzd2l0Y2ggKGFjdGlvbikge1xuICAgICAgICAgIGNhc2UgXCJkb3duXCI6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHNldFN0YXRlKFwiZHJhZ1wiKTtcbiAgICAgICAgICAgICAgc3RhcnREcmFnZ2luZyhyZXNpemVIYW5kbGVJZCwgZXZlbnQpO1xuICAgICAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICAgICAgb25EcmFnZ2luZ1xuICAgICAgICAgICAgICB9ID0gY2FsbGJhY2tzUmVmLmN1cnJlbnQ7XG4gICAgICAgICAgICAgIGlmIChvbkRyYWdnaW5nKSB7XG4gICAgICAgICAgICAgICAgb25EcmFnZ2luZyh0cnVlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIFwibW92ZVwiOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICAgICAgc3RhdGVcbiAgICAgICAgICAgICAgfSA9IGNvbW1pdHRlZFZhbHVlc1JlZi5jdXJyZW50O1xuICAgICAgICAgICAgICBpZiAoc3RhdGUgIT09IFwiZHJhZ1wiKSB7XG4gICAgICAgICAgICAgICAgc2V0U3RhdGUoXCJob3ZlclwiKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXNpemVIYW5kbGVyKGV2ZW50KTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSBcInVwXCI6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHNldFN0YXRlKFwiaG92ZXJcIik7XG4gICAgICAgICAgICAgIHN0b3BEcmFnZ2luZygpO1xuICAgICAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICAgICAgb25EcmFnZ2luZ1xuICAgICAgICAgICAgICB9ID0gY2FsbGJhY2tzUmVmLmN1cnJlbnQ7XG4gICAgICAgICAgICAgIGlmIChvbkRyYWdnaW5nKSB7XG4gICAgICAgICAgICAgICAgb25EcmFnZ2luZyhmYWxzZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNldFN0YXRlKFwiaW5hY3RpdmVcIik7XG4gICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gcmVnaXN0ZXJSZXNpemVIYW5kbGUocmVzaXplSGFuZGxlSWQsIGVsZW1lbnQsIGRpcmVjdGlvbiwge1xuICAgICAgLy8gQ29hcnNlIGlucHV0cyAoZS5nLiBmaW5nZXIvdG91Y2gpXG4gICAgICBjb2Fyc2U6IChfaGl0QXJlYU1hcmdpbnMkY29hcnMgPSBoaXRBcmVhTWFyZ2lucyA9PT0gbnVsbCB8fCBoaXRBcmVhTWFyZ2lucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogaGl0QXJlYU1hcmdpbnMuY29hcnNlKSAhPT0gbnVsbCAmJiBfaGl0QXJlYU1hcmdpbnMkY29hcnMgIT09IHZvaWQgMCA/IF9oaXRBcmVhTWFyZ2lucyRjb2FycyA6IDE1LFxuICAgICAgLy8gRmluZSBpbnB1dHMgKGUuZy4gbW91c2UpXG4gICAgICBmaW5lOiAoX2hpdEFyZWFNYXJnaW5zJGZpbmUgPSBoaXRBcmVhTWFyZ2lucyA9PT0gbnVsbCB8fCBoaXRBcmVhTWFyZ2lucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogaGl0QXJlYU1hcmdpbnMuZmluZSkgIT09IG51bGwgJiYgX2hpdEFyZWFNYXJnaW5zJGZpbmUgIT09IHZvaWQgMCA/IF9oaXRBcmVhTWFyZ2lucyRmaW5lIDogNVxuICAgIH0sIHNldFJlc2l6ZUhhbmRsZXJTdGF0ZSk7XG4gIH0sIFtkaXJlY3Rpb24sIGRpc2FibGVkLCBoaXRBcmVhTWFyZ2lucywgcmVnaXN0ZXJSZXNpemVIYW5kbGVXaXRoUGFyZW50R3JvdXAsIHJlc2l6ZUhhbmRsZUlkLCByZXNpemVIYW5kbGVyLCBzdGFydERyYWdnaW5nLCBzdG9wRHJhZ2dpbmddKTtcbiAgdXNlV2luZG93U3BsaXR0ZXJSZXNpemVIYW5kbGVyQmVoYXZpb3Ioe1xuICAgIGRpc2FibGVkLFxuICAgIGhhbmRsZUlkOiByZXNpemVIYW5kbGVJZCxcbiAgICByZXNpemVIYW5kbGVyLFxuICAgIHBhbmVsR3JvdXBFbGVtZW50XG4gIH0pO1xuICBjb25zdCBzdHlsZSA9IHtcbiAgICB0b3VjaEFjdGlvbjogXCJub25lXCIsXG4gICAgdXNlclNlbGVjdDogXCJub25lXCJcbiAgfTtcbiAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQoVHlwZSwge1xuICAgIC4uLnJlc3QsXG4gICAgY2hpbGRyZW4sXG4gICAgY2xhc3NOYW1lOiBjbGFzc05hbWVGcm9tUHJvcHMsXG4gICAgaWQ6IGlkRnJvbVByb3BzLFxuICAgIG9uQmx1cjogKCkgPT4gc2V0SXNGb2N1c2VkKGZhbHNlKSxcbiAgICBvbkZvY3VzOiAoKSA9PiBzZXRJc0ZvY3VzZWQodHJ1ZSksXG4gICAgcmVmOiBlbGVtZW50UmVmLFxuICAgIHJvbGU6IFwic2VwYXJhdG9yXCIsXG4gICAgc3R5bGU6IHtcbiAgICAgIC4uLnN0eWxlLFxuICAgICAgLi4uc3R5bGVGcm9tUHJvcHNcbiAgICB9LFxuICAgIHRhYkluZGV4LFxuICAgIC8vIENTUyBzZWxlY3RvcnNcbiAgICBcImRhdGEtcGFuZWwtZ3JvdXAtZGlyZWN0aW9uXCI6IGRpcmVjdGlvbixcbiAgICBcImRhdGEtcGFuZWwtZ3JvdXAtaWRcIjogZ3JvdXBJZCxcbiAgICBcImRhdGEtcmVzaXplLWhhbmRsZVwiOiBcIlwiLFxuICAgIFwiZGF0YS1yZXNpemUtaGFuZGxlLWFjdGl2ZVwiOiBzdGF0ZSA9PT0gXCJkcmFnXCIgPyBcInBvaW50ZXJcIiA6IGlzRm9jdXNlZCA/IFwia2V5Ym9hcmRcIiA6IHVuZGVmaW5lZCxcbiAgICBcImRhdGEtcmVzaXplLWhhbmRsZS1zdGF0ZVwiOiBzdGF0ZSxcbiAgICBcImRhdGEtcGFuZWwtcmVzaXplLWhhbmRsZS1lbmFibGVkXCI6ICFkaXNhYmxlZCxcbiAgICBcImRhdGEtcGFuZWwtcmVzaXplLWhhbmRsZS1pZFwiOiByZXNpemVIYW5kbGVJZFxuICB9KTtcbn1cblBhbmVsUmVzaXplSGFuZGxlLmRpc3BsYXlOYW1lID0gXCJQYW5lbFJlc2l6ZUhhbmRsZVwiO1xuXG5mdW5jdGlvbiBnZXRQYW5lbEVsZW1lbnQoaWQsIHNjb3BlID0gZG9jdW1lbnQpIHtcbiAgY29uc3QgZWxlbWVudCA9IHNjb3BlLnF1ZXJ5U2VsZWN0b3IoYFtkYXRhLXBhbmVsLWlkPVwiJHtpZH1cIl1gKTtcbiAgaWYgKGVsZW1lbnQpIHtcbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gZ2V0UGFuZWxFbGVtZW50c0Zvckdyb3VwKGdyb3VwSWQsIHNjb3BlID0gZG9jdW1lbnQpIHtcbiAgcmV0dXJuIEFycmF5LmZyb20oc2NvcGUucXVlcnlTZWxlY3RvckFsbChgW2RhdGEtcGFuZWxdW2RhdGEtcGFuZWwtZ3JvdXAtaWQ9XCIke2dyb3VwSWR9XCJdYCkpO1xufVxuXG5mdW5jdGlvbiBnZXRJbnRlcnNlY3RpbmdSZWN0YW5nbGUocmVjdE9uZSwgcmVjdFR3bywgc3RyaWN0KSB7XG4gIGlmICghaW50ZXJzZWN0cyhyZWN0T25lLCByZWN0VHdvLCBzdHJpY3QpKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IDAsXG4gICAgICB5OiAwLFxuICAgICAgd2lkdGg6IDAsXG4gICAgICBoZWlnaHQ6IDBcbiAgICB9O1xuICB9XG4gIHJldHVybiB7XG4gICAgeDogTWF0aC5tYXgocmVjdE9uZS54LCByZWN0VHdvLngpLFxuICAgIHk6IE1hdGgubWF4KHJlY3RPbmUueSwgcmVjdFR3by55KSxcbiAgICB3aWR0aDogTWF0aC5taW4ocmVjdE9uZS54ICsgcmVjdE9uZS53aWR0aCwgcmVjdFR3by54ICsgcmVjdFR3by53aWR0aCkgLSBNYXRoLm1heChyZWN0T25lLngsIHJlY3RUd28ueCksXG4gICAgaGVpZ2h0OiBNYXRoLm1pbihyZWN0T25lLnkgKyByZWN0T25lLmhlaWdodCwgcmVjdFR3by55ICsgcmVjdFR3by5oZWlnaHQpIC0gTWF0aC5tYXgocmVjdE9uZS55LCByZWN0VHdvLnkpXG4gIH07XG59XG5cbmV4cG9ydCB7IFBhbmVsLCBQYW5lbEdyb3VwLCBQYW5lbFJlc2l6ZUhhbmRsZSwgYXNzZXJ0LCBnZXRJbnRlcnNlY3RpbmdSZWN0YW5nbGUsIGdldFBhbmVsRWxlbWVudCwgZ2V0UGFuZWxFbGVtZW50c0Zvckdyb3VwLCBnZXRQYW5lbEdyb3VwRWxlbWVudCwgZ2V0UmVzaXplSGFuZGxlRWxlbWVudCwgZ2V0UmVzaXplSGFuZGxlRWxlbWVudEluZGV4LCBnZXRSZXNpemVIYW5kbGVFbGVtZW50c0Zvckdyb3VwLCBnZXRSZXNpemVIYW5kbGVQYW5lbElkcywgaW50ZXJzZWN0cyB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-resizable-panels/dist/react-resizable-panels.development.node.esm.js\n");

/***/ })

};
;